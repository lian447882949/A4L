###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Jun/2016  13:18:41 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\Common\System_Config.c               #
#    Command line =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\Common\System_Config.c -D            #
#                    USE_STDPERIPH_DRIVER -D USE_STM32100B_EVAL -D            #
#                    STM32F10X_CL -lc F:\软件工程\平台正式代码001\Benze_MainB #
#                    oard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph #
#                    _Template\EWARM\Debug\List\ -lA                          #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\ -o F:\软件工程\平台正式代码001\Benze_MainBoar #
#                    d\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Te #
#                    mplate\EWARM\Debug\Obj\ --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I F:\软件工程\平台正式代码001\Benze_MainBoard\ba #
#                    oma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Templa #
#                    te\EWARM\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\ -I F:\软件工程\平台正式代码001\Benze_Mai #
#                    nBoard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeri #
#                    ph_Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph #
#                    _Driver\inc\ -I F:\软件工程\平台正式代码001\Benze_MainBo #
#                    ard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_ #
#                    Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph_Dr #
#                    iver\src\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\..\..\Project/Common\ -I                  #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/TW8836\ -I F:\软件工程\平台正式代码001\B #
#                    enze_MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x #
#                    _StdPeriph_Template\EWARM\..\..\..\Project/CAN\ -I       #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/FM\ -I F:\软件工程\平台正式代码001\Benze #
#                    _MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x_Std #
#                    Periph_Template\EWARM\..\..\..\Project/ARM\ -I           #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\  #
#                    -On -I "C:\Program Files\IAR Systems\Embedded Workbench  #
#                    6.0_2\arm\CMSIS\Include\"                                #
#    List file    =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\System_Config.lst                              #
#    Object file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\Obj\System_Config.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\benci_newC_V45\Project\Common\System_Config.c
      1          #define _SYSTEM_CONFIG_C_
      2          
      3          #include "compile.h"
      4          //#include "stm32f10x_lib.h"
      5          //#include "system_config.h"
      6          #include "port.h"
      7          
      8          
      9          #include "stm32f10x_gpio.h"	
     10          #include "libr.h"	
     11          #include "main.h"	
     12          #include "includes.h"
     13          
     14          #define SPI1_DR_Address  0x4001300C 
     15          #define SPI2_DR_Address    0x4000380C
     16          
     17          #define ADC1_DR_Address     0x4001244C
     18          #define USART1_DR_Base      0x40013804
     19          #define USART2_DR_Base      0x40004404
     20          #define I2C1_SLAVE_ADDRESS7 0xa2
     21          
     22          
     23          void NVIC_Configuration(void);
     24          void LcdShow_Init(void);
     25          
     26          
     27          
     28          void I2C_Configuration(void);
     29          void ExInt_Config(void);
     30          void Timer_Config(void);
     31          void DAC_Config(void);
     32          void SPI_FLASH_Init(void);
     33          void USART_Configuration(void);
     34          void RTC_Configuration(void);
     35          void Time_Adjust(void);
     36          u32 Time_Regulate(void);
     37          
     38          
     39          
     40          	  
     41          //系统时钟配置
     42          void RCC_Configuration(void)
     43          {
     44            DWORD   i;
     45           // ErrorStatus HSEStartUpStatus;
     46            
     47            /* RCC system reset(for debug purpose) */
     48            RCC_DeInit();
     49          
     50            /* Enable HSE */
     51           // RCC_HSEConfig(RCC_HSE_ON);
     52          
     53            /* Wait till HSE is ready */
     54          //  HSEStartUpStatus = RCC_WaitForHSEStartUp();
     55          
     56           // if(HSEStartUpStatus == SUCCESS)
     57            {
     58              /* Enable Prefetch Buffer */
     59              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
     60          
     61              /* Flash 2 wait state */
     62              FLASH_SetLatency(FLASH_Latency_2);
     63          
     64              /* HCLK = SYSCLK */ //AHB分频
     65              RCC_HCLKConfig(RCC_SYSCLK_Div1);
     66          
     67              /* PCLK2 = HCLK *///APB2分频
     68              RCC_PCLK2Config(RCC_HCLK_Div1);
     69          
     70              /* PCLK1 = HCLK/2 *///APB1分频   //包括定时器
     71              //定时器的始终只要分频就自动倍频*2；现在为56M
     72              RCC_PCLK1Config(RCC_HCLK_Div1);//RCC_HCLK_Div2
     73          
     74              /* ADCCLK = PCLK2/4 */ //ADC分频
     75              RCC_ADCCLKConfig(RCC_PCLK2_Div4);
     76          
     77              /* PLLCLK = 8MHz * 3 = 24 MHz *///PLL倍频
     78              RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_6);//4//RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_4);//4
     79          
     80              /* Enable PLL */
     81              RCC_PLLCmd(ENABLE);
     82          
     83              /* Wait till PLL is ready */
     84              i=0;
     85              while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
     86              {
     87          		delay_5us();
     88          		if(i++>80000)
     89          			break;
     90              }
     91          
     92              /* Select PLL as system clock source */
     93              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
     94              i=0;
     95              /* Wait till PLL is used as system clock source */
     96              while(RCC_GetSYSCLKSource() != 0x08)
     97              {
     98          		delay_5us();
     99          		if(i++>80000)
    100          			break;
    101              }
    102            }
    103          
    104            /* 使能对应的外设时钟 --------------------------------------------------*/
    105            /* TIM2 ,TIM3 and TIM4 clocks enable */
    106            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 | RCC_APB1Periph_TIM3 |RCC_APB1Periph_TIM4, ENABLE);
    107          
    108            /* DMA clock enable */
    109            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1 ,ENABLE);
    110          
    111            /* Enable ADC1 clock */
    112            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    113            //RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
    114            //RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
    115          
    116            /* SPI2 Periph clock enable */
    117            RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);  
    118          
    119            /* Enable USART2 clocks */
    120            RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);    
    121            RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);   
    122            RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);   
    123            RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);   
    124            RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);  
    125            /* DAC Periph clock enable */
    126            RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
    127            
    128            /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks */
    129            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC
    130                   | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
    131          
    132          }
    133          
    134          void RCC_Close(void)
    135          {
    136            //DWORD   i;
    137          GPIO_InitTypeDef GPIO_InitStructure;
    138          
    139          #if 0
    140            /* 使能对应的外设时钟 --------------------------------------------------*/
    141            /* TIM2 ,TIM3 and TIM4 clocks enable */
    142            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 | RCC_APB1Periph_TIM3 |RCC_APB1Periph_TIM4, DISABLE);
    143          
    144            /* DMA clock enable */
    145            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1 ,DISABLE);
    146          
    147            /* Enable ADC1 clock */
    148            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, DISABLE);
    149            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, DISABLE);
    150            //RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
    151          
    152            /* SPI2 Periph clock enable */
    153            RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, DISABLE);  
    154          
    155            /* Enable USART2 clocks */
    156            RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, DISABLE);    
    157            RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, DISABLE);   
    158            RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, DISABLE);   
    159            RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, DISABLE);   
    160            RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, DISABLE);  
    161            /* DAC Periph clock enable */
    162            RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
    163            
    164            /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE and AFIO clocks */
    165            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC
    166                   | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
    167          
    168          #endif
    169          
    170            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|
    171            								GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|
    172            								GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|
    173            								GPIO_Pin_15;
    174            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    175            GPIO_Init(GPIOA, &GPIO_InitStructure);  
    176          
    177            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|
    178            								GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_9|
    179            								GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|
    180            								GPIO_Pin_15;
    181            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    182            GPIO_Init(GPIOB, &GPIO_InitStructure);  //GPIO_Pin_8|
    183            
    184            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|
    185            								GPIO_Pin_5|GPIO_Pin_8|GPIO_Pin_9|
    186            								GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|
    187            								GPIO_Pin_15;
    188            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    189            GPIO_Init(GPIOC, &GPIO_InitStructure);  //GPIO_Pin_6|GPIO_Pin_7|
    190           
    191            
    192            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|
    193            								GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|
    194            								GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;
    195            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    196            GPIO_Init(GPIOD, &GPIO_InitStructure);  
    197              
    198          
    199          
    200          }
    201          
    202          //系统时钟配置
    203          void SYSCLKConfig_STOP(void)
    204          {
    205            DWORD   i;
    206           // ErrorStatus HSEStartUpStatus;
    207            
    208            /* Enable HSE */
    209           // RCC_HSEConfig(RCC_HSE_ON);
    210          
    211            /* Wait till HSE is ready */
    212          //  HSEStartUpStatus = RCC_WaitForHSEStartUp();
    213          
    214           // if(HSEStartUpStatus == SUCCESS)
    215            {
    216              /* Enable PLL */
    217              RCC_PLLCmd(ENABLE);
    218          
    219              /* Wait till PLL is ready */
    220              i=0;
    221              while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
    222              {
    223          		delay_5us();
    224          		if(i++>80000)
    225          			break;
    226              }
    227          
    228              /* Select PLL as system clock source */
    229              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    230              i=0;
    231              /* Wait till PLL is used as system clock source */
    232              while(RCC_GetSYSCLKSource() != 0x08)
    233              {
    234          		delay_5us();
    235          		if(i++>80000)
    236          			break;
    237              }
    238            }
    239          
    240          
    241          
    242          }
    243          
    244          //IO口配置
    245          void GPIO_Configuration(void)
    246          {
    247          
    248          	GPIO_InitTypeDef GPIO_InitStructure;
    249          	GPIO_AFIODeInit();
    250          
    251          
    252          	//-------------power -and mute------------------------
    253          	GPIO_InitStructure.GPIO_Pin = MUTE_ALL_OUT_MUTE_PIN;
    254          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    255          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    256          	GPIO_Init(MUTE_ALL_OUT_MUTE_PORT, &GPIO_InitStructure);
    257          
    258          
    259          	GPIO_InitStructure.GPIO_Pin = MUTE_NAVI_MUTE_PIN;
    260          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    261          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    262          	GPIO_Init(MUTE_NAVI_MUTE_PORT, &GPIO_InitStructure);
    263          
    264          	GPIO_InitStructure.GPIO_Pin = MUTE_PHONE_MUTE_PIN;
    265          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    266          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    267          	GPIO_Init(MUTE_PHONE_MUTE_PORT, &GPIO_InitStructure);
    268          
    269          	GPIO_InitStructure.GPIO_Pin = SW_GPS_CAR_PIN;
    270          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    271          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    272          	GPIO_Init(SW_GPS_CAR_PORT, &GPIO_InitStructure);
    273          
    274          	GPIO_InitStructure.GPIO_Pin = POWER_SYSTEM_PIN;
    275          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    276          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    277          	GPIO_Init(POWER_SYSTEM_PORT, &GPIO_InitStructure);
    278          
    279          
    280          
    281          
    282          
    283          
    284          	GPIO_InitStructure.GPIO_Pin = POWER_REAR_CAMERA_PIN;
    285          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    286          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    287          	GPIO_Init(POWER_REAR_CAMERA_PORT, &GPIO_InitStructure);
    288          
    289          	GPIO_InitStructure.GPIO_Pin = POWER_DVD_PIN;
    290          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    291          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    292          	GPIO_Init(POWER_DVD_PORT, &GPIO_InitStructure);
    293          
    294          	GPIO_InitStructure.GPIO_Pin = POWER_DVBCMMB_PIN;
    295          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    296          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    297          	GPIO_Init(POWER_DVBCMMB_PORT, &GPIO_InitStructure);
    298          
    299          
    300          
    301          
    302          	GPIO_InitStructure.GPIO_Pin = POWER_AUDIO_PIN;
    303          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    304          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    305          	GPIO_Init(POWER_AUDIO_PORT, &GPIO_InitStructure);
    306          
    307          
    308          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
    309          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    310          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    311          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    312          
    313          	GPIO_InitStructure.GPIO_Pin = POWER_CarRec_PIN;
    314          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    315          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    316          	GPIO_Init(POWER_CarRec_PORT, &GPIO_InitStructure);
    317          
    318          
    319          
    320          
    321          	GPIO_InitStructure.GPIO_Pin = POWER_TFT_LED__PIN;
    322          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    323          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    324          	GPIO_Init(POWER_TFT_LED__PORT, &GPIO_InitStructure);
    325          	//------------MCU comunication--------------------
    326          	GPIO_InitStructure.GPIO_Pin = COM_MCU_RX_PIN;
    327          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    328          	GPIO_Init(COM_MCU_RX_PORT, &GPIO_InitStructure);
    329          	GPIO_InitStructure.GPIO_Pin = COM_MCU_TX_PIN;
    330          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    331          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    332          	GPIO_Init(COM_MCU_TX_PORT, &GPIO_InitStructure);
    333          
    334          	//------------GPS comunication--------------------
    335          	GPIO_InitStructure.GPIO_Pin = COM_GPS_RX_PIN;
    336          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    337          	GPIO_Init(COM_GPS_RX_PORT, &GPIO_InitStructure);
    338          	GPIO_InitStructure.GPIO_Pin = COM_GPS_TX_PIN;
    339          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    340          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    341          	GPIO_Init(COM_GPS_TX_PORT, &GPIO_InitStructure);
    342          	//----------------------DVD---------------------
    343          	GPIO_InitStructure.GPIO_Pin = COM_DVD_IPOD_CMMB_MP5_RX_PIN;
    344          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    345          	GPIO_Init(COM_DVD_IPOD_CMMB_MP5_RX_PORT, &GPIO_InitStructure);
    346          
    347          	GPIO_InitStructure.GPIO_Pin = COM_DVD_IPOD_CMMB_MP5_TX_PIN;
    348          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    349          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    350          	GPIO_Init(COM_DVD_IPOD_CMMB_MP5_TX_PORT, &GPIO_InitStructure);
    351          
    352          	//----------------------BT---------------------
    353          	GPIO_InitStructure.GPIO_Pin = COM_BT_RX_PIN;
    354          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//GPIO_Mode_IN_FLOATING;
    355          	GPIO_Init(COM_BT_RX_PORT, &GPIO_InitStructure);
    356          
    357          	GPIO_InitStructure.GPIO_Pin = COM_BT_TX_PIN;
    358          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    359          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
    360          	GPIO_Init(COM_BT_TX_PORT, &GPIO_InitStructure);
    361          	GPIO_PinRemapConfig(GPIO_Remap_USART1, ENABLE);
    362          	//-----------ACC WAKEUP---------------------------
    363          	/* Connect Key Button EXTI Line to Key Button GPIO Pin */
    364          	GPIO_InitStructure.GPIO_Pin = DET_ACCCHECK_PIN;
    365          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    366          	GPIO_Init(DET_ACCCHECK_PORT, &GPIO_InitStructure);
    367          	//-------------DET-------------------------------
    368          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
    369          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    370          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    371          	GPIO_Init(GPIOC, &GPIO_InitStructure);
    372          	//------------------CAM DET-----------------------------------
    373          	GPIO_InitStructure.GPIO_Pin = DET_CAM_PIN;
    374          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    375          	GPIO_Init(DET_CAM_PORT, &GPIO_InitStructure);
    376          
    377          	//-------------------DIMMER-------------------------------
    378          	//GPIO_InitStructure.GPIO_Pin = DIMMER_PIN;
    379          	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    380          	//GPIO_Init(DIMMER_PORT, &GPIO_InitStructure);
    381          
    382          
    383          	//-------------KnobKey--Miller.Tao,20140911------------------------
    384          
    385          	GPIO_InitStructure.GPIO_Pin = KnobENC_ENDA_PIN;
    386          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    387          	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    388          	GPIO_Init(KnobENC_ENDA_PORT, &GPIO_InitStructure);
    389          
    390          	GPIO_InitStructure.GPIO_Pin = KnobENC_ENDB_PIN;
    391          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    392          	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    393          	GPIO_Init(KnobENC_ENDB_PORT, &GPIO_InitStructure);
    394          	
    395          	GPIO_InitStructure.GPIO_Pin = KnobKey_PIN;
    396          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    397          	GPIO_Init(KnobKey_PORT, &GPIO_InitStructure);
    398          	//-----------------KEY-----------------------------------
    399          
    400          	
    401          	GPIO_InitStructure.GPIO_Pin = KEY_DVD_CP_PIN;
    402          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    403          	GPIO_Init(KEY_DVD_CP_PORT, &GPIO_InitStructure);
    404          	//-------------AV -------------------------------
    405          	
    406          	GPIO_InitStructure.GPIO_Pin = AV_IIC_CLK_PIN;
    407          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    408          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    409          	GPIO_Init(AV_IIC_CLK_PORT, &GPIO_InitStructure);
    410          	GPIO_InitStructure.GPIO_Pin = AV_IIC_DAT_PIN;
    411          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    412          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    413          	GPIO_Init(AV_IIC_DAT_PORT, &GPIO_InitStructure);
    414          	//----------------CMMB---------------------------
    415          	GPIO_InitStructure.GPIO_Pin = CMMB_IR_PIN;
    416          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    417          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    418          	GPIO_Init(CMMB_IR_PORT, &GPIO_InitStructure);
    419          	//----------------------CAN--------------------
    420          
    421          
    422          	GPIO_InitStructure.GPIO_Pin = CAN_EN_PIN;
    423          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    424          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    425          	GPIO_Init(CAN_EN_PORT, &GPIO_InitStructure);
    426          	GPIO_InitStructure.GPIO_Pin = CAN_STB_PIN;
    427          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    428          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    429          	GPIO_Init(CAN_STB_PORT, &GPIO_InitStructure);
    430          	GPIO_InitStructure.GPIO_Pin = CAN_ERR_PIN;
    431          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    432          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    433          	GPIO_Init(CAN_ERR_PORT, &GPIO_InitStructure);
    434          	/* Configure CAN pin: RX */
    435          	GPIO_InitStructure.GPIO_Pin = CAN_RX_PIN;
    436          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    437          	GPIO_Init(CAN_RX_PORT, &GPIO_InitStructure);
    438          	/* Configure CAN pin: TX */
    439          	GPIO_InitStructure.GPIO_Pin = CAN_TX_PIN;
    440          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    441          	GPIO_Init(CAN_TX_PORT, &GPIO_InitStructure);
    442          
    443          	//GPIO_PinRemapConfig(GPIO_Remap1_CAN1, ENABLE);
    444          
    445          	/* Configure CAN2 pin: RX */
    446          	GPIO_InitStructure.GPIO_Pin = CAN2_RX_PIN;
    447          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    448          	GPIO_Init(CAN2_RX_PORT, &GPIO_InitStructure);
    449          	/* Configure CAN pin: TX */
    450          	GPIO_InitStructure.GPIO_Pin = CAN2_TX_PIN;
    451          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    452          	GPIO_Init(CAN2_TX_PORT, &GPIO_InitStructure);
    453          
    454          	//GPIO_PinRemapConfig(GPIO_Remap1_CAN, ENABLE);
    455          
    456          	/* Configure CAN2 pin: RX */
    457          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
    458          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    459          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    460          
    461          	GPIO_InitStructure.GPIO_Pin = (CTOUCH_INT_PIN);
    462          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    463          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    464          	GPIO_Init(CTOUCH_INT_PORT, &GPIO_InitStructure);
    465          
    466          	GPIO_InitStructure.GPIO_Pin = (CTOUCH_RST_PIN);
    467          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    468          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    469          	GPIO_Init(CTOUCH_RST_PORT, &GPIO_InitStructure);
    470          
    471          	/*!< Configure sEE_I2C pins: SCL */
    472          	GPIO_InitStructure.GPIO_Pin = CTOUCH_SCL_PIN;
    473          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    474          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;//
    475          	GPIO_Init(CTOUCH_SCL_PORT, &GPIO_InitStructure);
    476          
    477          	/*!< Configure sEE_I2C pins: SDA */
    478          	GPIO_InitStructure.GPIO_Pin = CTOUCH_SDA_PIN;
    479          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    480          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    481          	GPIO_Init(CTOUCH_SDA_PORT, &GPIO_InitStructure);
    482          
    483          	GPIO_InitStructure.GPIO_Pin = (GPIO_Pin_13);
    484          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    485          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    486          	GPIO_Init(GPIOC, &GPIO_InitStructure);
    487          
    488          	GPIO_InitStructure.GPIO_Pin = (MTN5_CLK_PIN|MTN5_DATA_PIN);
    489          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    490          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    491          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    492          
    493          	GPIO_InitStructure.GPIO_Pin = (MTN5_BUSY_PIN);
    494          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    495          	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    496          	GPIO_Init(MTN5_BUSY_PORT, &GPIO_InitStructure);
    497          
    498          }
    499          
    500          void System_Normal_ClkSetup(void)
    501          {
    502          
    503              //-----------------------config clock--------------------------
    504              /* Enable PWR and BKP clock */
    505              RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
    506              PWR_WakeUpPinCmd(ENABLE);
    507              /* Allow access to BKP Domain */
    508              PWR_BackupAccessCmd(ENABLE);
    509              //----------------------config AFIO---------------------
    510              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    511               //----------------------config CAN---------------------
    512              RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
    513              RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE);
    514              //----------------------config GPIO--------------------
    515              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA  | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | \
    516                                     RCC_APB2Periph_GPIOD  , ENABLE);
    517              //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA  | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | \
    518              //                       RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG , ENABLE);//Miller.Tao2014-09-10
    519          	//----------------------config DMA---------------------
    520          	RCC_AHBPeriphClockCmd( RCC_AHBPeriph_DMA1 | RCC_AHBPeriph_SRAM | RCC_AHBPeriph_FLITF | RCC_AHBPeriph_CRC , ENABLE);
    521              //----------------------config uart -------------------
    522             // RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    523              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    524          	
    525              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    526              RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
    527          	
    528              //RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    529              //----------------------config timer--------------------------
    530              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    531          	
    532              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    533              //----------------------config ADC1--------------------------
    534          
    535          
    536          }
    537          
    538          
    539          void GPIO_keylight_Configuration(void)
    540          {}
    541          	
    542          void GPIO_Off_Init(void)
    543          {
    544          /* PORT A Definition*/
    545          #if 0 //miller.tao20150731
    546          	DAC_SetChannel2Data(DAC_Align_8b_R, 0x0);	//DAC
    547          	GPIO_WriteBit(GPIOA, P_RADIO_PWR, Bit_RESET);
    548          
    549          	GPIO_WriteBit(GPIOA, P_DVR_PWR, Bit_RESET);
    550          	GPIO_WriteBit(GPIOA, P_M_IN2, Bit_RESET);
    551          	GPIO_WriteBit(GPIOA, P_DISC_LED, Bit_RESET);
    552          
    553          /* PORT B Definition*/
    554          
    555          	GPIO_WriteBit(GPIOB, P_PEC_RST, Bit_RESET);
    556          	GPIO_WriteBit(GPIOB, P_TV_SDA, Bit_RESET);
    557          	GPIO_WriteBit(GPIOB, P_AUDIO_SEL1, Bit_SET);
    558          	GPIO_WriteBit(GPIOB, P_AUDIO_SEL2, Bit_RESET);
    559          	GPIO_WriteBit(GPIOB, P_TW8823_SCL, Bit_RESET);
    560          	GPIO_WriteBit(GPIOB, P_TW8823_SDA, Bit_RESET);
    561          
    562          	GPIO_WriteBit(GPIOB, P_PEC_CLK, Bit_RESET);
    563          	GPIO_WriteBit(GPIOB, P_MAIN_SCL, Bit_RESET);
    564          	GPIO_WriteBit(GPIOB, P_MAIN_SDA, Bit_RESET);
    565          	GPIO_WriteBit(GPIOB, P_8823_SPI_CS, Bit_RESET);
    566          	
    567          	GPIO_WriteBit(GPIOB, P_GOD_RST, Bit_RESET);
    568          
    569          
    570          	GPIO_WriteBit(GPIOC, P_TV_PWR , Bit_RESET);
    571          	GPIO_WriteBit(GPIOC, P_DVD_RST , Bit_RESET);
    572          
    573          	GPIO_WriteBit(GPIOC, P_TV_SEL , Bit_RESET);
    574          
    575          
    576          	GPIO_WriteBit(GPIOD, P_TW8823_RST , Bit_RESET);
    577          
    578          	GPIO_WriteBit(GPIOD, P_DTVTXD_ATVSCL , Bit_RESET);
    579          
    580          	GPIO_WriteBit(GPIOD, P_RES_SEL , Bit_RESET);
    581          	GPIO_WriteBit(GPIOD, P_LED_COL1 , Bit_RESET);
    582          	GPIO_WriteBit(GPIOD, P_LED_COL2 , Bit_RESET);
    583          	GPIO_WriteBit(GPIOD, P_MUTE , Bit_RESET);
    584          	GPIO_WriteBit(GPIOD, P_MUTE_ZONE , Bit_RESET);
    585          	GPIO_WriteBit(GPIOD, P_STBY , Bit_RESET);
    586          
    587          	GPIO_WriteBit(GPIOE, P_DVDUSB_SEL , Bit_RESET);
    588          	GPIO_WriteBit(GPIOE, P_DVR_WRXD , Bit_RESET);
    589          	GPIO_WriteBit(GPIOE, P_2ZONE_WTXD, Bit_RESET);
    590          	GPIO_WriteBit(GPIOE, P_2ZONE_RTXD , Bit_RESET);
    591              #endif
    592          
    593          	
    594          }
    595          
    596          
    597          void GPIO_On_Init(void)
    598          {
    599          /* PORT A Definition*/
    600                 #if 0//miller.tao20150731
    601          	DAC_SetChannel2Data(DAC_Align_8b_R, 0x0);   //DAC
    602          	GPIO_WriteBit(GPIOA, P_RADIO_PWR, Bit_RESET);
    603          
    604          	GPIO_WriteBit(GPIOA, P_DVR_PWR, Bit_RESET);
    605          	GPIO_WriteBit(GPIOA, P_M_IN2, Bit_RESET);
    606          	GPIO_WriteBit(GPIOA, P_DISC_LED, Bit_RESET);
    607          
    608          	GPIO_WriteBit(GPIOB, P_PEC_RST, Bit_SET);
    609          	GPIO_WriteBit(GPIOB, P_TV_SDA, Bit_SET);
    610          	GPIO_WriteBit(GPIOB, P_AUDIO_SEL1, Bit_SET);
    611          	GPIO_WriteBit(GPIOB, P_AUDIO_SEL2, Bit_RESET);
    612          	GPIO_WriteBit(GPIOB, P_TW8823_SCL, Bit_SET);
    613          	GPIO_WriteBit(GPIOB, P_TW8823_SDA, Bit_SET);
    614          	
    615          	GPIO_WriteBit(GPIOB, P_PEC_CLK, Bit_SET);
    616          	GPIO_WriteBit(GPIOB, P_MAIN_SCL, Bit_SET);
    617          	GPIO_WriteBit(GPIOB, P_MAIN_SDA, Bit_SET);
    618          	GPIO_WriteBit(GPIOB, P_8823_SPI_CS, Bit_RESET);
    619          	
    620          	GPIO_WriteBit(GPIOB, P_GOD_RST, Bit_SET);
    621          
    622          
    623          	GPIO_WriteBit(GPIOC, P_TV_PWR , Bit_RESET);
    624          	GPIO_WriteBit(GPIOC, P_DVD_RST , Bit_RESET);
    625          
    626          	GPIO_WriteBit(GPIOC, P_TV_SEL , Bit_RESET);
    627          
    628          
    629          	GPIO_WriteBit(GPIOD, P_DTVTXD_ATVSCL , Bit_SET);
    630          
    631          	GPIO_WriteBit(GPIOD, P_RES_SEL , Bit_RESET);
    632          	GPIO_WriteBit(GPIOD, P_LED_COL1 , Bit_RESET);
    633          	GPIO_WriteBit(GPIOD, P_LED_COL2 , Bit_RESET);
    634          	GPIO_WriteBit(GPIOD, P_MUTE , Bit_RESET);
    635          	GPIO_WriteBit(GPIOD, P_MUTE_ZONE , Bit_RESET);
    636          	GPIO_WriteBit(GPIOD, P_STBY , Bit_RESET);
    637          
    638          	GPIO_WriteBit(GPIOE, P_DVDUSB_SEL , Bit_RESET);
    639          	GPIO_WriteBit(GPIOE, P_DVR_WRXD , Bit_RESET);
    640          	GPIO_WriteBit(GPIOE, P_2ZONE_WTXD, Bit_SET);
    641          	GPIO_WriteBit(GPIOE, P_2ZONE_RTXD , Bit_SET);
    642                  #endif
    643          }	
    644          
    645          //中断配置
    646          void NVIC_Configuration(void)
    647          {
    648          	NVIC_InitTypeDef NVIC_InitStructure;
    649          
    650          
    651          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    652          
    653          	/* Enable the TIM2 gloabal Interrupt */
    654          	NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
    655          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
    656          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    657          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    658          	NVIC_Init(&NVIC_InitStructure);
    659          
    660          	/* Enable the TIM2 gloabal Interrupt */
    661          	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    662          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    663          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    664          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    665          	NVIC_Init(&NVIC_InitStructure);
    666          	
    667          #if 0
    668          	//------------MCU-----------------------------------
    669          	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    670          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    671          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    672          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    673          	NVIC_Init(&NVIC_InitStructure);
    674          	
    675          #endif
    676          	//------------GPS-----------------------------------
    677          	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
    678          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    679          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    680          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    681          	NVIC_Init(&NVIC_InitStructure);
    682          	#if 0
    683          	//------------Q3 Rec-----------------------------------
    684          	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
    685          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    686          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    687          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    688          	NVIC_Init(&NVIC_InitStructure);
    689          
    690          	//------------DVD ipod-----------------------------------
    691          	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
    692          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    693          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    694          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    695          	NVIC_Init(&NVIC_InitStructure);
    696          	
    697          #endif
    698          	//------------BT-----------------------------------
    699          	#if 0
    700          	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    701          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    702          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    703          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    704          	NVIC_Init(&NVIC_InitStructure);
    705          	//---------------CAN-------------------------------
    706          #endif
    707          
    708              NVIC_InitStructure.NVIC_IRQChannel = CAN1_RX0_IRQn;
    709              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    710              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    711              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    712              NVIC_Init(&NVIC_InitStructure);
    713          
    714              NVIC_InitStructure.NVIC_IRQChannel = CAN2_RX0_IRQn;
    715              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    716              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    717              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    718              NVIC_Init(&NVIC_InitStructure);
    719          
    720          
    721          #if 0
    722            NVIC_InitStructure.NVIC_IRQChannel = RTCAlarm_IRQn;//RTCAlarm_IRQChannel;
    723            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    724            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    725            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    726            NVIC_Init(&NVIC_InitStructure);
    727            #endif
    728          	//---------------SYSTEM TICK------------------------
    729          	//n=0x00~0x03 设置Systick为抢占优先级0
    730          	//n=0x04~0x07 设置Systick为抢占优先级1
    731          	//n=0x08~0x0B 设置Systick为抢占优先级2
    732          	//n=0x0C~0x0F 设置Systick为抢占优先级3
    733          
    734          	/*
    735          	这时不能显式的看出抢先式优先级与子优先级，写入的优先级需要根据优先级组的配置来选择。
    736          	NVIC_SetPriority函数指定中断优先级的寄存器位（STM32只用4位来表示优先级）的数据，
    737          	例如中断优先级组设置为了2，即高2位用于指定抢占式优先级，低2位用于指定响应优先级，
    738          	0x00~0x03高2位为0，所以抢占优先级为0；0x04~0x07高2位为1，所以抢占优先级为1，以此类推。
    739          	*/
    740          
    741          	NVIC_SetPriority(SysTick_IRQn, 1);
    742          
    743          }
    744          
    745          
    746          void EXIT_Control(BYTE type,BYTE on_off)
    747          {}
    748          
    749          void EXIT_all_off(void)
    750          {
    751          	// USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);
    752          	//SysTick_ITConfig(DISABLE);
    753          }	
    754          
    755          
    756          
    757          /*******************************************************************************
    758          * Function Name  : RTC_Configuration
    759          * Description    : Configures the RTC.
    760          * Input          : None
    761          * Output         : None
    762          * Return         : None
    763          *******************************************************************************/
    764          #if 1
    765          void RTC_Configuration(void)
    766          {
    767          	DWORD i;
    768          	 EXTI_InitTypeDef EXTI_InitStructure;
    769          
    770          	  /* Configure EXTI Line17(RTC Alarm) to generate an interrupt on rising edge */
    771          	  EXTI_InitStructure.EXTI_Line = EXTI_Line17;
    772          	  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    773          	  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
    774          	  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    775          	  EXTI_Init(&EXTI_InitStructure);
    776            
    777            /* Enable PWR and BKP clocks */
    778            RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
    779          
    780            /* Allow access to BKP Domain */
    781            PWR_BackupAccessCmd(ENABLE);
    782          
    783            /* Reset Backup Domain */
    784            BKP_DeInit();
    785          
    786            /* Enable the LSI OSC */
    787            RCC_LSICmd(ENABLE);
    788            /* Wait till LSI is ready */
    789          	i=0;
    790            while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
    791            {
    792          		delay_5us();
    793          		if(i++>80000)
    794          			break;		
    795            }
    796          
    797            /* Select the RTC Clock Source */
    798            RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
    799          
    800            /* Enable RTC Clock */
    801            RCC_RTCCLKCmd(ENABLE);
    802          
    803            /* Wait for RTC registers synchronization */
    804            RTC_WaitForSynchro();
    805          
    806            /* Wait until last write operation on RTC registers has finished */
    807            RTC_WaitForLastTask();
    808          
    809            /* Enable the RTC Second */
    810            //RTC_ITConfig(RTC_IT_SEC, ENABLE);
    811          
    812            /* Wait until last write operation on RTC registers has finished */
    813            RTC_WaitForLastTask();
    814          
    815            /* Set RTC prescaler: set RTC period to 1sec */
    816            RTC_SetPrescaler(40000);
    817          
    818            /* Wait until last write operation on RTC registers has finished */
    819            RTC_WaitForLastTask();
    820          
    821            /* To output second signal on Tamper pin, the tamper functionality
    822          	   must be disabled (by default this functionality is disabled) */
    823           // BKP_TamperPinCmd(DISABLE);
    824          
    825            /* Enable the RTC Second Output on Tamper Pin */
    826            //BKP_RTCOutputConfig(BKP_RTCOutputSource_Second);
    827          
    828            /* Enable the RTC Alarm interrupt */
    829            RTC_ITConfig(RTC_IT_ALR, ENABLE);
    830          	/* Wait until last write operation on RTC registers has finished */
    831            RTC_WaitForLastTask();	
    832          }
    833          	
    834          #else
    835          	
    836          void RTC_Configuration(void)
    837          {
    838          	/* Enable PWR and BKP clocks */
    839          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
    840          
    841          	/* Allow access to BKP Domain */
    842          	PWR_BackupAccessCmd(ENABLE);
    843          
    844          	/* Reset Backup Domain */
    845          	BKP_DeInit();
    846          
    847          	/* Enable the LSI OSC */
    848          	RCC_LSICmd(ENABLE);
    849          	/* Wait till LSI is ready */
    850          	while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
    851          		{}
    852          	/* Select the RTC Clock Source */
    853          	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
    854          
    855          	/* Enable RTC Clock */
    856          	RCC_RTCCLKCmd(ENABLE);
    857          
    858          	/* Wait for RTC registers synchronization */
    859          	RTC_WaitForSynchro();
    860          
    861          	/* Wait until last write operation on RTC registers has finished */
    862          	RTC_WaitForLastTask();
    863          
    864          	/* Enable the RTC Second */
    865          	RTC_ITConfig(RTC_IT_ALR, ENABLE);
    866          
    867          	/* Wait until last write operation on RTC registers has finished */
    868          	RTC_WaitForLastTask();
    869          
    870          	/* Set RTC prescaler: set RTC period to 1sec */
    871          	RTC_SetPrescaler(40000);
    872          
    873          	/* Wait until last write operation on RTC registers has finished */
    874          	RTC_WaitForLastTask();
    875          
    876          }
    877          #endif
    878          
    879          
    880          
    881          /*******************************************************************************
    882          * Function Name  : Time_Adjust
    883          * Description    : Adjusts time.
    884          * Input          : None
    885          * Output         : None
    886          * Return         : None
    887          *******************************************************************************/
    888          void Time_Adjust(void)
    889          {
    890            /* Wait until last write operation on RTC registers has finished */
    891            RTC_WaitForLastTask();
    892            /* Change the current time */
    893            RTC_SetCounter(Time_Regulate());
    894            /* Wait until last write operation on RTC registers has finished */
    895            RTC_WaitForLastTask();
    896          }
    897          
    898          /*******************************************************************************
    899          * Function Name  : Time_Regulate
    900          * Description    : Returns the time entered by user, using Hyperterminal.
    901          * Input          : None
    902          * Output         : None
    903          * Return         : Current time RTC counter value
    904          *******************************************************************************/
    905          u32 Time_Regulate(void)
    906          {
    907            u32 Tmp_HH = 0x21, Tmp_MM = 0x31, Tmp_SS = 0x32;
    908          
    909            /* Return the value to store in RTC counter register */
    910            return((Tmp_HH*3600 + Tmp_MM*60 + Tmp_SS));
    911          }
    912          
    913          /*******************************************************************************
    914          * Function Name  : DMA_Configuration
    915          * Description    : Configures the DMA.
    916          * Input          : None
    917          * Output         : None
    918          * Return         : None
    919          *******************************************************************************/
    920          void DMA_Configuration(BYTE *Receive_Buf,u16 NumByteToRead)
    921          {
    922            
    923          }
    924          
    925          
    926          //外部中断
    927          void ExInt_Config(void)
    928          {
    929              //EXTI_InitTypeDef EXTI_InitStructure;
    930          
    931          #if 0
    932            //RDS
    933             GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);
    934             /* Configure EXTI Line9 to generate an interrupt on falling edge */
    935             EXTI_InitStructure.EXTI_Line = EXTI_Line0;
    936             EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    937             EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    938             EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    939             EXTI_Init(&EXTI_InitStructure);	
    940          #endif	
    941          
    942            //ENCODE
    943           //  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource1);
    944             /* Configure EXTI Line9 to generate an interrupt on falling edge */
    945           /*  EXTI_InitStructure.EXTI_Line = EXTI_Line1;
    946             EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    947             EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;//EXTI_Trigger_Rising;//
    948             EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    949             EXTI_Init(&EXTI_InitStructure);	*/
    950             
    951          
    952          
    953          
    954          }
    955          
    956          
    957          /*******************************************************************************
    958          * Function Name  : SPI_FLASH_Init
    959          * Description    : Initializes the peripherals used by the SPI FLASH driver.
    960          * Input          : None
    961          * Output         : None
    962          * Return         : None
    963          *******************************************************************************/
    964          void SPI_FLASH_Init(void)
    965          {
    966          
    967          }
    968          
    969          //定时器
    970          /*******************************************************************************
    971          * Function Name  : LcdShow_Init
    972          * Description    : Configure the lcd dispaly: TIM4 initialize in Output Compare
    973          *                  Timing Mode
    974          * Input          : None
    975          * Return         : None
    976          * Comment        : TIM2 Configuration: Output Compare Timing Mode:
    977                             TIM2CLK = 36 *2 =72MHz, Prescaler = 17, TIM2 counter clock = 4 MHz
    978                             TIM2 update Period = ARR / TIM2 counter Period = 2 ms
    979                             CC1 OC period = 1ms
    980          *******************************************************************************/
    981          	void Main_SysTick_Config(void)
    982          	{
    983          		SysTick_Config(SystemCoreClock / 1000);
    984          	
    985          	}
    986          	
    987          	void TIMER_Configuration(void)
    988          	{
    989          		TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    990          		TIM_OCInitTypeDef TIM_OCInitStructure;
    991          		//TIM_ICInitTypeDef TIM_ICInitStructure;
    992          
    993          		
    994          #if  0
    995          		CCR1_Val = 200;
    996          		CCR2_Val = 5000;
    997          		CCR3_Val = 2000;
    998          		CCR4_Val = 4000;
    999          
   1000          		/* ---------------------------------------------------------------
   1001          		TIM2 Configuration: Output Compare Timing Mode:
   1002          		TIM2CLK = 36 MHz, Prescaler = 4, TIM2 counter clock = 7.2 MHz
   1003          		CC1 update rate = TIM2 counter clock / CCR1_Val = 146.48 Hz
   1004          		CC2 update rate = TIM2 counter clock / CCR2_Val = 219.7 Hz
   1005          		CC3 update rate = TIM2 counter clock / CCR3_Val = 439.4 Hz
   1006          		CC4 update rate = TIM2 counter clock / CCR4_Val =  878.9 Hz
   1007          		--------------------------------------------------------------- */
   1008          		/* Time base configuration */
   1009          	    TIM_TimeBaseStructure.TIM_Period = 65535;
   1010          	    TIM_TimeBaseStructure.TIM_Prescaler = 0;
   1011          	    TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1012          	    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1013          	    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
   1014          	    /* Prescaler configuration */
   1015          	    TIM_PrescalerConfig(TIM2, 71, TIM_PSCReloadMode_Immediate);
   1016          	    /* Output Compare Timing Mode configuration: Channel1 */
   1017          	    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   1018          	    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1019          	    TIM_OCInitStructure.TIM_Pulse = CCR1_Val;
   1020          	    //TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   1021          	    TIM_OC1Init(TIM2, &TIM_OCInitStructure);
   1022          	    TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Disable);
   1023          	    /* Output Compare Timing Mode configuration: Channel2 */
   1024          	    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1025          	    TIM_OCInitStructure.TIM_Pulse = CCR2_Val;
   1026          	    TIM_OC2Init(TIM2, &TIM_OCInitStructure);
   1027          	    TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Disable);
   1028          	    /* Output Compare Timing Mode configuration: Channel3 */
   1029          	    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1030          	    TIM_OCInitStructure.TIM_Pulse = CCR3_Val;
   1031          	    TIM_OC3Init(TIM2, &TIM_OCInitStructure);
   1032          	    TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Disable);
   1033          	    /* Output Compare Timing Mode configuration: Channel4 */
   1034          	    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1035          	    TIM_OCInitStructure.TIM_Pulse = CCR4_Val;
   1036          	    TIM_OC4Init(TIM2, &TIM_OCInitStructure);
   1037          	    TIM_OC4PreloadConfig(TIM2, TIM_OCPreload_Disable);
   1038          	    /* TIM IT enable */
   1039          	    TIM_ITConfig(TIM2, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4, DISABLE)
   1040          	    ;
   1041          	    //TIM_ITConfig(TIM2, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4, ENABLE);
   1042          	    /* TIM2 enable counter */
   1043          	    TIM_Cmd(TIM2, ENABLE);
   1044          #endif
   1045          		
   1046          		GPIO_PinRemapConfig(GPIO_FullRemap_TIM3,ENABLE);
   1047          		TIM_TimeBaseStructure.TIM_Period = 4001;
   1048          		TIM_TimeBaseStructure.TIM_Prescaler = 0;
   1049          		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1050          		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1051          		TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   1052          		/* Prescaler configuration */
   1053          		TIM_PrescalerConfig(TIM3, 71, TIM_PSCReloadMode_Immediate);
   1054          		/* Output Compare Timing Mode configuration: Channel1 */
   1055          		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   1056          		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   1057          		TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable; //使能  互补 输出状态
   1058          		TIM_OCInitStructure.TIM_Pulse = 4000;
   1059          		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
   1060          		TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;     //互补 输出极性高
   1061          		TIM_OCInitStructure.TIM_OCIdleState  =  TIM_OCIdleState_Set;    
   1062                  TIM_OCInitStructure.TIM_OCNIdleState =  TIM_OCIdleState_Reset; 
   1063          		TIM_OC3Init(TIM3, &TIM_OCInitStructure);
   1064          
   1065          
   1066          	
   1067          	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
   1068          	
   1069          	TIM_ARRPreloadConfig(TIM3, ENABLE);
   1070          	TIM_CtrlPWMOutputs(TIM3, ENABLE);
   1071          	//TIM_CCxNCmd(TIM1,TIM_Channel_2, TIM_CCxN_Enable);
   1072          		/* TIM IT enable */
   1073          	   // TIM_ITConfig(TIM2, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4, DISABLE)
   1074          	   // ;
   1075          		//TIM_ITConfig(TIM2, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4, ENABLE);
   1076          		/* TIM2 enable counter */
   1077          		TIM_Cmd(TIM3, ENABLE);
   1078          	//PWM_Configuration(CCR1_Val-20);
   1079          	}
   1080          
   1081          
   1082          void PWM_Configuration(vu16 ccr_data)
   1083          {
   1084             // TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
   1085              TIM_OCInitTypeDef TIM_OCInitStructure;
   1086          	
   1087              /* Output Compare Timing Mode configuration: Channel1 */
   1088              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   1089              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   1090              TIM_OCInitStructure.TIM_Pulse = ccr_data;
   1091              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
   1092              TIM_OC3Init(TIM3, &TIM_OCInitStructure);
   1093          
   1094              /* TIM IT enable */
   1095             // TIM_ITConfig(TIM2, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4, DISABLE)
   1096             // ;
   1097              //TIM_ITConfig(TIM2, TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4, ENABLE);
   1098              /* TIM2 enable counter */
   1099              TIM_Cmd(TIM3, ENABLE);
   1100          
   1101          }
   1102          
   1103          
   1104          //ADC
   1105          void ADC_Config(void)
   1106          {
   1107          	ADC_InitTypeDef ADC_InitStructure;
   1108          	ADC_StructInit(&ADC_InitStructure);
   1109          	/* ADC1 configuration ------------------------------------------------------*/
   1110          	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   1111          	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   1112          	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   1113          	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   1114          	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   1115          	ADC_InitStructure.ADC_NbrOfChannel = 1; // 1
   1116          	ADC_Init(ADC1, &ADC_InitStructure);
   1117          	/* ADC1 regular channel14 configuration */
   1118          	//ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 1, ADC_SampleTime_55Cycles5);
   1119          	//ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 2, ADC_SampleTime_55Cycles5);
   1120          	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_55Cycles5);
   1121          	//ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 2, ADC_SampleTime_55Cycles5);
   1122          	//ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 4, ADC_SampleTime_55Cycles5);
   1123          	/* Enable ADC1 DMA */
   1124          	ADC_DMACmd(ADC1, ENABLE);
   1125          	/* Enable ADC1 */
   1126          	ADC_Cmd(ADC1, ENABLE);
   1127          	/* Enable ADC1 reset calibaration register */
   1128          	ADC_ResetCalibration(ADC1);
   1129          	/* Check the end of ADC1 reset calibration register */
   1130          	while (ADC_GetResetCalibrationStatus(ADC1));
   1131          	/* Start ADC1 calibaration */
   1132          	ADC_StartCalibration(ADC1);
   1133          	/* Check the end of ADC1 calibration */
   1134          	while (ADC_GetCalibrationStatus(ADC1));
   1135          	ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能ADC1软件开始转换
   1136          }
   1137          
   1138          /*******************************************************************************
   1139           * Function Name  : NVIC_STANBY_CAN_Configuration
   1140           * Description    : Configures Vector Table base location.
   1141           * Input          : None
   1142           * Output         : None
   1143           * Return         : None
   1144           *******************************************************************************/
   1145          void NVIC_STANBY_CAN_Configuration(void)
   1146          {
   1147              NVIC_InitTypeDef NVIC_InitStructure;
   1148              /* Configure one bit for preemption priority */
   1149              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   1150          
   1151          
   1152          #if 1
   1153              NVIC_InitStructure.NVIC_IRQChannel = CAN1_RX1_IRQn;//USB_LP_CAN1_RX0_IRQn;
   1154              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0;
   1155              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x2;
   1156              NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
   1157              NVIC_Init(&NVIC_InitStructure);
   1158          #endif
   1159              /* CAN FIFO0 message pending interrupt enable */
   1160              CAN_ITConfig(CAN1, CAN_IT_FMP0 | CAN_IT_FF0, DISABLE);
   1161              /* CAN FIFO0 message pending interrupt enable */
   1162              //CAN_ITConfig(CAN2, CAN_IT_FMP0, DISABLE);
   1163          
   1164          
   1165          }
   1166          
   1167          
   1168          
   1169          
   1170          void DAC_Config(void)
   1171          {
   1172             DAC_InitTypeDef  DAC_InitStructure;
   1173             //GPIO_InitTypeDef GPIO_InitStructure;
   1174            
   1175            DAC_InitStructure.DAC_Trigger = DAC_Trigger_None; //DAC_Trigger_Software;
   1176            DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_Noise;
   1177            DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bits8_0;
   1178            DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
   1179            DAC_Init(DAC_Channel_1, &DAC_InitStructure);
   1180          
   1181            /* Enable DAC Channel1 */
   1182            DAC_Cmd(DAC_Channel_1, ENABLE);
   1183            DAC_SetChannel1Data(DAC_Align_8b_R, 0x80);	
   1184          }
   1185          
   1186          void STM32_Canbus_Config(void)
   1187          {}
   1188          
   1189          /*******************************************************************************
   1190           * Function Name  : USART_Configuration
   1191           * Description	  : Configures the different usart.
   1192           * Input		  : None
   1193           * Output		  : None
   1194           * Return		  : None
   1195           *******************************************************************************/
   1196          void USART_Configuration(void)
   1197          {
   1198          	USART_InitTypeDef USART_InitStructure;
   1199          	/*************************DVD IPOD MP5******************************/
   1200          #if 1 //miller.tao20150718
   1201          	USART_InitStructure.USART_BaudRate = 9600;
   1202          
   1203          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   1204          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
   1205          	USART_InitStructure.USART_Parity = USART_Parity_No;
   1206          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   1207          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   1208          	/* Configure USART5 */
   1209          	USART_Init(UART5, &USART_InitStructure);
   1210          	/* Enable USART5 Receive  interrupts */
   1211          	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);
   1212          	USART_ITConfig(UART5, USART_IT_TXE, DISABLE);
   1213          	/* Enable the USART5 */
   1214          	USART_Cmd(UART5, ENABLE);
   1215          
   1216          #endif
   1217          
   1218          	/*************************MCU TO MCU******************************/
   1219          	USART_InitStructure.USART_BaudRate = 115200;
   1220          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   1221          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
   1222          	USART_InitStructure.USART_Parity = USART_Parity_No;
   1223          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   1224          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   1225          	USART_Init(USART2, &USART_InitStructure);
   1226          	/* Enable USART2 DMA TX request */
   1227          	//USART_DMACmd(USART2, USART_DMAReq_Tx, ENABLE);
   1228          	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   1229          	USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
   1230          	USART_Cmd(USART2, ENABLE);
   1231          
   1232          	/*************************MCU TO GPS******************************/
   1233          	USART_InitStructure.USART_BaudRate = 19200;
   1234          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   1235          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
   1236          	USART_InitStructure.USART_Parity = USART_Parity_No;
   1237          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   1238          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   1239          	USART_Init(USART3, &USART_InitStructure);
   1240          	/* Enable USART2 DMA TX request */
   1241          	//USART_DMACmd(USART2, USART_DMAReq_Tx, ENABLE);
   1242          	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
   1243          	USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
   1244          	USART_Cmd(USART3, ENABLE);
   1245          
   1246          	/*************************MCU TO BT******************************/
   1247          	#if 0//miler.tao20150810
   1248          	USART_InitStructure.USART_BaudRate = 19200;
   1249          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   1250          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
   1251          	USART_InitStructure.USART_Parity = USART_Parity_No;
   1252          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   1253          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   1254          	USART_Init(USART1, &USART_InitStructure);
   1255          	/* Enable USART1 DMA TX request */
   1256          	//USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);
   1257          	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   1258          	USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
   1259          	USART_Cmd(USART1, ENABLE);
   1260          	#endif
   1261          
   1262          #if 0
   1263          	/*************************MCU TO KEY REC******************************/
   1264          	USART_InitStructure.USART_BaudRate = 19200;
   1265          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   1266          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
   1267          	USART_InitStructure.USART_Parity = USART_Parity_No;
   1268          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   1269          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   1270          	USART_Init(UART4, &USART_InitStructure);
   1271          	/* Enable USART1 DMA TX request */
   1272          	//USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);
   1273          	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   1274          	USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
   1275          	USART_Cmd(UART4, ENABLE);
   1276          
   1277          #endif
   1278          }
   1279          
   1280          
   1281          void I2C_Configuration(void)
   1282          {
   1283          	I2C_InitTypeDef I2C_InitStruct;
   1284          
   1285          	I2C_DeInit(I2C1);
   1286          	I2C_InitStruct.I2C_Mode                = I2C_Mode_SMBusDevice;
   1287              I2C_InitStruct.I2C_DutyCycle           = I2C_DutyCycle_2;
   1288              I2C_InitStruct.I2C_OwnAddress1         = I2C1_SLAVE_ADDRESS7;
   1289              I2C_InitStruct.I2C_Ack                 = I2C_Ack_Enable;
   1290              I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   1291              I2C_InitStruct.I2C_ClockSpeed          = 100000;
   1292              I2C_Init(I2C1, &I2C_InitStruct);
   1293          	I2C_Cmd(I2C1, ENABLE);
   1294          
   1295          	  // Enable I2C2 event and buffer interrupt 
   1296            I2C_ITConfig(I2C2, I2C_IT_EVT | I2C_IT_BUF, ENABLE);
   1297          
   1298          }
   1299          
   1300          
   1301          
   1302          /*******************************************************************************
   1303           * Function Name  : CAN_Configuration
   1304           * Description    : Configures the can.
   1305           * Input          : None
   1306           * Output         : None
   1307           * Return         : None
   1308           *******************************************************************************/
   1309          void CAN_Configuration(void)
   1310          {
   1311                  LF_CanBus_Config();
   1312          }
   1313          /*******************************************************************************
   1314           * Function Name  : EXIT_Configuration
   1315           * Description    : Configure a ext it
   1316           * Input          : None
   1317           * Output         : None
   1318           * Return         : None
   1319           *******************************************************************************/
   1320          void EXIT_Configuration(void)
   1321          {
   1322              EXTI_InitTypeDef EXTI_InitStructure;
   1323              EXTI_DeInit();
   1324              /*
   1325                EXTI_InitStructure.EXTI_Line = WAKEUP_EXTI_LINE;
   1326                EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Event; //EXTI_Mode_Interrupt;
   1327                EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
   1328                EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   1329                EXTI_Init(&EXTI_InitStructure);
   1330          
   1331                */
   1332              /* Configure EXTI Line17(RTC Alarm) to generate an interrupt on rising edge */
   1333              EXTI_ClearITPendingBit(EXTI_Line17);
   1334              EXTI_InitStructure.EXTI_Line = EXTI_Line17;
   1335              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   1336              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   1337              EXTI_InitStructure.EXTI_LineCmd =ENABLE;// DISABLE;
   1338              EXTI_Init(&EXTI_InitStructure);
   1339          
   1340          	EXTI_ClearITPendingBit(EXTI_Line2);
   1341          	
   1342          	
   1343          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource2);
   1344              EXTI_InitStructure.EXTI_Line = EXTI_Line2;
   1345              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   1346              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   1347              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   1348              EXTI_Init(&EXTI_InitStructure);
   1349          
   1350          }
   1351          /*******************************************************************************
   1352           * Function Name  : ADC_Configuration
   1353           * Description    : Configure a key ADC
   1354           * Input          : None
   1355           * Output         : None
   1356           * Return         : None
   1357           *******************************************************************************/
   1358          void ADC_Configuration(void)
   1359          {
   1360              ADC_InitTypeDef ADC_InitStructure;
   1361              ADC_StructInit(&ADC_InitStructure);
   1362              /* ADC1 configuration ------------------------------------------------------*/
   1363              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   1364              ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   1365              ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   1366              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   1367              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   1368              ADC_InitStructure.ADC_NbrOfChannel = 1; // 1
   1369              ADC_Init(ADC1, &ADC_InitStructure);
   1370              /* ADC1 regular channel14 configuration */
   1371              //ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 1, ADC_SampleTime_55Cycles5);
   1372              //ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 2, ADC_SampleTime_55Cycles5);
   1373              ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_55Cycles5);
   1374              //ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 2, ADC_SampleTime_55Cycles5);
   1375          	//ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 4, ADC_SampleTime_55Cycles5);
   1376              /* Enable ADC1 DMA */
   1377              ADC_DMACmd(ADC1, ENABLE);
   1378              /* Enable ADC1 */
   1379              ADC_Cmd(ADC1, ENABLE);
   1380              /* Enable ADC1 reset calibaration register */
   1381              ADC_ResetCalibration(ADC1);
   1382              /* Check the end of ADC1 reset calibration register */
   1383              while (ADC_GetResetCalibrationStatus(ADC1));
   1384              /* Start ADC1 calibaration */
   1385              ADC_StartCalibration(ADC1);
   1386              /* Check the end of ADC1 calibration */
   1387              while (ADC_GetCalibrationStatus(ADC1));
   1388              ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能ADC1软件开始转换
   1389          }
   1390          
   1391          
   1392          
   1393          void Acc_Wdg_Config(void)
   1394          {
   1395          
   1396              /* Check if the system has resumed from IWDG reset */
   1397              if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
   1398              {
   1399                  /* IWDGRST flag set */
   1400          
   1401          
   1402                  /* Clear reset flags */
   1403                  RCC_ClearFlag();
   1404              }
   1405              else
   1406              {
   1407                  /* IWDGRST flag is not set */
   1408                  /* Reset GPIO_LED pin 6 */
   1409          
   1410              }
   1411          
   1412          
   1413          
   1414              /* IWDG timeout equal to 280 ms (the timeout may varies due to LSI frequency
   1415                 dispersion) */
   1416              /* Enable write access to IWDG_PR and IWDG_RLR registers */
   1417              IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
   1418          
   1419              /* IWDG counter clock: 40KHz(LSI) / 32 = 1.25 KHz */
   1420              IWDG_SetPrescaler(IWDG_Prescaler_32);
   1421          
   1422              /* Set counter reload value to 349 */
   1423              IWDG_SetReload(3200);//2500,2s    xs (if 3s is 30000/8=? fill here)
   1424          
   1425              /* Reload IWDG counter */
   1426              IWDG_ReloadCounter();
   1427          
   1428              /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
   1429              IWDG_Enable();
   1430          }
   1431          void System_Standby_Reset_ClkSetup(void)
   1432          {
   1433              GPIO_InitTypeDef GPIO_InitStructure;
   1434              GPIO_AFIODeInit();
   1435          
   1436              //-----------------------config clock--------------------------
   1437              /* Enable PWR and BKP clock */
   1438              RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
   1439              /* Enable WKUP pin */
   1440              PWR_WakeUpPinCmd(ENABLE);
   1441          
   1442              /* Allow access to BKP Domain */
   1443              PWR_BackupAccessCmd(ENABLE);
   1444          
   1445              RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);//enable can1
   1446              //RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE);
   1447          
   1448              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//can1 io port open
   1449              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   1450              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, DISABLE);//DISABLE,MillerTao
   1451              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, DISABLE);//DISABLE,MillerTao
   1452              //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, DISABLE);//Miller.Tao2014-09-10
   1453              //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, DISABLE);
   1454              //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG, DISABLE);
   1455              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, DISABLE);
   1456          
   1457              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, DISABLE);
   1458              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, DISABLE);
   1459              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_SRAM, DISABLE);
   1460              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FLITF, DISABLE);
   1461              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_CRC, DISABLE);
   1462              //spi
   1463          
   1464          
   1465              //uart
   1466              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, DISABLE);
   1467              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, DISABLE);
   1468              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, DISABLE);
   1469              //RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, DISABLE);
   1470              //RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, DISABLE);
   1471              //adc
   1472              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, DISABLE);
   1473             // RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, DISABLE);
   1474              //timer
   1475              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, DISABLE);
   1476              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, DISABLE);
   1477              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, DISABLE);
   1478              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, DISABLE);
   1479              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, DISABLE);
   1480              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, DISABLE);
   1481              //
   1482              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, DISABLE);
   1483              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM9, DISABLE);
   1484              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM10, DISABLE);
   1485              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM11, DISABLE);
   1486              //
   1487              
   1488              //-----------ACC WAKEUP---------------------------
   1489              /* Connect Key Button EXTI Line to Key Button GPIO Pin */
   1490              GPIO_InitStructure.GPIO_Pin = P_ACC_DET;
   1491              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   1492              GPIO_Init(P_ACC_PORT, &GPIO_InitStructure);
   1493          
   1494              //----------------------CAN--------------------
   1495              GPIO_InitStructure.GPIO_Pin = P_CAN_PWR_EN;
   1496              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   1497              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
   1498              GPIO_Init(GPIOA, &GPIO_InitStructure);
   1499             #if 0
   1500              GPIO_InitStructure.GPIO_Pin = CAN_STB_PIN;
   1501              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   1502              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
   1503              GPIO_Init(CAN_STB_PORT, &GPIO_InitStructure);
   1504              GPIO_InitStructure.GPIO_Pin = CAN_ERR_PIN;
   1505              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   1506              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
   1507              GPIO_Init(CAN_ERR_PORT, &GPIO_InitStructure);
   1508             #endif
   1509              /* Configure CAN pin: RX */
   1510              GPIO_InitStructure.GPIO_Pin = P_CAN_RXD;
   1511              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   1512              GPIO_Init(GPIOA, &GPIO_InitStructure);
   1513              /* Configure CAN pin: TX */
   1514              GPIO_InitStructure.GPIO_Pin = P_CAN_TXD;
   1515              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   1516              GPIO_Init(GPIOA, &GPIO_InitStructure);
   1517          
   1518              //GPIO_PinRemapConfig(GPIO_Remap1_CAN1, ENABLE);
   1519          
   1520             #if 0
   1521              /* Configure CAN pin: RX */
   1522              //GPIO_InitStructure.GPIO_Pin = CAN2_RX_PIN;
   1523              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   1524              //GPIO_Init(CAN2_RX_PORT, &GPIO_InitStructure);
   1525              /* Configure CAN pin: TX */
   1526              //GPIO_InitStructure.GPIO_Pin = CAN2_TX_PIN;
   1527              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   1528              //GPIO_Init(CAN2_TX_PORT, &GPIO_InitStructure);
   1529              #endif
   1530          
   1531              //GPIO_PinRemapConfig(GPIO_Remap1_CAN2, ENABLE);
   1532          
   1533          
   1534          }
   1535          
   1536          void Acc_PwrEnterStandyMode(void)
   1537          {
   1538              CanRxMsg RxMessage;
   1539              static u8 uPreMediaStatus, uPrePreMediaStatus;
   1540              uPreMediaStatus = uPreMediaStatus;
   1541              uPrePreMediaStatus = uPrePreMediaStatus;
   1542              System_Standby_Reset_ClkSetup();
   1543              //GPIO_DeInit(GPIOA);
   1544              //GPIO_DeInit(GPIOB);
   1545              GPIO_DeInit(GPIOC);
   1546              GPIO_DeInit(GPIOD);
   1547              //GPIO_DeInit(GPIOE);//Miller.Tao
   1548              //GPIO_DeInit(GPIOF);
   1549              //GPIO_DeInit(GPIOG);
   1550              Main_SysTick_Config();
   1551              Acc_Wdg_Config();
   1552          
   1553              CAN_Configuration();
   1554          
   1555              NVIC_STANBY_CAN_Configuration();
   1556          
   1557              //CAN_STB_SET();
   1558              //CAN_EN_SET();
   1559              /* Reload IWDG counter */
   1560              IWDG_ReloadCounter();
   1561          
   1562              m_BMW_CAN.benze_Pwr_acc = SYSTEM_POWER_OFF;
   1563          	m_BMW_CAN.benze_Pwr_acc_Aux = SYSTEM_POWER_OFF;//Miller.Tao20141104
   1564          	m_BMW_CAN.AudioPwr = SYSTEM_POWER_OFF;
   1565          	m_BMW_CAN.AccPwr = SYSTEM_POWER_OFF;
   1566              //SysDelay(100);
   1567              g_stuCurPower.wPowerWamkeupTimer = 1000;
   1568          
   1569              while(1)
   1570              {
   1571                
   1572                
   1573                
   1574                  //CAN_STB_SET();
   1575                  //CAN_EN_SET();
   1576                  if(CAN_GetFlagStatus(CAN1, CAN_FLAG_FMP0) == SET || CAN_GetFlagStatus(CAN1, CAN_FLAG_FF0) == SET)
   1577                  {
   1578                      CAN_Receive(CAN1, CAN_FIFO0, &RxMessage);
   1579          			
   1580          			LF_CanBus_PowerOn(RxMessage);
   1581          
   1582                      CAN_ClearFlag(CAN1, CAN_FLAG_FMP0);
   1583                      CAN_ClearFlag(CAN1, CAN_FLAG_FF0);
   1584          
   1585                  }
   1586                  if(m_BMW_CAN.benze_Pwr_acc == SYSTEM_POWER_ON)
   1587                      break;
   1588          
   1589                  if(!g_stuCurPower.wPowerWamkeupTimer)
   1590                      break;
   1591                  if(!ACC_PIN_STATUS())
   1592                      break;
   1593              }
   1594              if(!ACC_PIN_STATUS())
   1595                  return;
   1596          
   1597          
   1598          
   1599              if(m_BMW_CAN.benze_Pwr_acc != SYSTEM_POWER_ON)
   1600              {
   1601                  //----------------------------before  enter standby to close clk
   1602                  System_Standby_Reset_ClkSetup();
   1603          
   1604                  //GPIO_DeInit(GPIOA);
   1605                  //GPIO_DeInit(GPIOB);
   1606                  GPIO_DeInit(GPIOC);
   1607                  GPIO_DeInit(GPIOD);
   1608                  //GPIO_DeInit(GPIOE);//Miller.Tao
   1609                  //GPIO_DeInit(GPIOF);
   1610                  //GPIO_DeInit(GPIOG);
   1611                  //CAN_STB_RESET();
   1612                  //CAN_EN_RESET();
   1613                  //-----------------------------
   1614          
   1615                  PWR_EnterSTANDBYMode();
   1616              }
   1617          
   1618          
   1619          }
   1620          
   1621          /*******************************************************************************
   1622           * Function Name  : MCU_Init
   1623           * Description    : init hardwre.
   1624           * Input          : None
   1625           * Output         : None
   1626           * Return         : None
   1627           *******************************************************************************/
   1628          
   1629          void MCU_Init(void)
   1630          {
   1631                 	System_Normal_ClkSetup();
   1632          	GPIO_Configuration();
   1633          	Main_SysTick_Config();
   1634          	
   1635          	Acc_Wdg_Config();
   1636          	TIMER_Configuration();
   1637          	USART_Configuration();
   1638          	Delay_1ms(50);
   1639          	CAN_Configuration();
   1640          	
   1641          	EXIT_Configuration();
   1642          	NVIC_Configuration();
   1643          	//RTC_Configuration();
   1644          }
   1645          
   1646          
   1647          
   1648          
   1649          
   1650          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  ADC_Config
             24 -> ADC_Cmd
             24 -> ADC_DMACmd
             24 -> ADC_GetCalibrationStatus
             24 -> ADC_GetResetCalibrationStatus
             24 -> ADC_Init
             24 -> ADC_RegularChannelConfig
             24 -> ADC_ResetCalibration
             24 -> ADC_SoftwareStartConvCmd
             24 -> ADC_StartCalibration
             24 -> ADC_StructInit
       24  ADC_Configuration
             24 -> ADC_Cmd
             24 -> ADC_DMACmd
             24 -> ADC_GetCalibrationStatus
             24 -> ADC_GetResetCalibrationStatus
             24 -> ADC_Init
             24 -> ADC_RegularChannelConfig
             24 -> ADC_ResetCalibration
             24 -> ADC_SoftwareStartConvCmd
             24 -> ADC_StartCalibration
             24 -> ADC_StructInit
       48  Acc_PwrEnterStandyMode
             32 -> Acc_Wdg_Config
             32 -> CAN_ClearFlag
             32 -> CAN_Configuration
             32 -> CAN_GetFlagStatus
             32 -> CAN_Receive
             32 -> GPIO_DeInit
             32 -> GPIO_ReadInputDataBit
             32 -> IWDG_ReloadCounter
             32 -> LF_CanBus_PowerOn
             32 -> Main_SysTick_Config
             32 -> NVIC_STANBY_CAN_Configuration
             32 -> PWR_EnterSTANDBYMode
             32 -> System_Standby_Reset_ClkSetup
             48 -> __aeabi_memcpy4
        8  Acc_Wdg_Config
              8 -> IWDG_Enable
              8 -> IWDG_ReloadCounter
              8 -> IWDG_SetPrescaler
              8 -> IWDG_SetReload
              8 -> IWDG_WriteAccessCmd
              8 -> RCC_ClearFlag
              8 -> RCC_GetFlagStatus
        8  CAN_Configuration
              8 -> LF_CanBus_Config
       24  DAC_Config
             24 -> DAC_Cmd
             24 -> DAC_Init
             24 -> DAC_SetChannel1Data
        0  DMA_Configuration
       16  EXIT_Configuration
             16 -> EXTI_ClearITPendingBit
             16 -> EXTI_DeInit
             16 -> EXTI_Init
             16 -> GPIO_EXTILineConfig
        0  EXIT_Control
        0  EXIT_all_off
        0  ExInt_Config
        8  GPIO_Configuration
              8 -> GPIO_AFIODeInit
              8 -> GPIO_Init
              8 -> GPIO_PinRemapConfig
        0  GPIO_Off_Init
        0  GPIO_On_Init
        0  GPIO_keylight_Configuration
       24  I2C_Configuration
             24 -> I2C_Cmd
             24 -> I2C_DeInit
             24 -> I2C_ITConfig
             24 -> I2C_Init
        8  MCU_Init
              8 -> Acc_Wdg_Config
              8 -> CAN_Configuration
              8 -> Delay_1ms
              8 -> EXIT_Configuration
              8 -> GPIO_Configuration
              8 -> Main_SysTick_Config
              8 -> NVIC_Configuration
              8 -> System_Normal_ClkSetup
              8 -> TIMER_Configuration
              8 -> USART_Configuration
        8  Main_SysTick_Config
              8 -> SysTick_Config
        8  NVIC_Configuration
              8 -> NVIC_Init
              8 -> NVIC_PriorityGroupConfig
              8 -> NVIC_SetPriority
        8  NVIC_STANBY_CAN_Configuration
              8 -> CAN_ITConfig
              8 -> NVIC_Init
              8 -> NVIC_PriorityGroupConfig
        0  NVIC_SetPriority
       24  PWM_Configuration
             24 -> TIM_Cmd
             24 -> TIM_OC3Init
        8  RCC_Close
              8 -> GPIO_Init
        8  RCC_Configuration
              8 -> FLASH_PrefetchBufferCmd
              8 -> FLASH_SetLatency
              8 -> RCC_ADCCLKConfig
              8 -> RCC_AHBPeriphClockCmd
              8 -> RCC_APB1PeriphClockCmd
              8 -> RCC_APB2PeriphClockCmd
              8 -> RCC_DeInit
              8 -> RCC_GetFlagStatus
              8 -> RCC_GetSYSCLKSource
              8 -> RCC_HCLKConfig
              8 -> RCC_PCLK1Config
              8 -> RCC_PCLK2Config
              8 -> RCC_PLLCmd
              8 -> RCC_PLLConfig
              8 -> RCC_SYSCLKConfig
              8 -> delay_5us
       16  RTC_Configuration
             16 -> BKP_DeInit
             16 -> EXTI_Init
             16 -> PWR_BackupAccessCmd
             16 -> RCC_APB1PeriphClockCmd
             16 -> RCC_GetFlagStatus
             16 -> RCC_LSICmd
             16 -> RCC_RTCCLKCmd
             16 -> RCC_RTCCLKConfig
             16 -> RTC_ITConfig
             16 -> RTC_SetPrescaler
             16 -> RTC_WaitForLastTask
             16 -> RTC_WaitForSynchro
             16 -> delay_5us
        0  SPI_FLASH_Init
        0  STM32_Canbus_Config
        8  SYSCLKConfig_STOP
              8 -> RCC_GetFlagStatus
              8 -> RCC_GetSYSCLKSource
              8 -> RCC_PLLCmd
              8 -> RCC_SYSCLKConfig
              8 -> delay_5us
        8  SysTick_Config
              8 -> NVIC_SetPriority
        8  System_Normal_ClkSetup
              8 -> PWR_BackupAccessCmd
              8 -> PWR_WakeUpPinCmd
              8 -> RCC_AHBPeriphClockCmd
              8 -> RCC_APB1PeriphClockCmd
              8 -> RCC_APB2PeriphClockCmd
        8  System_Standby_Reset_ClkSetup
              8 -> GPIO_AFIODeInit
              8 -> GPIO_Init
              8 -> PWR_BackupAccessCmd
              8 -> PWR_WakeUpPinCmd
              8 -> RCC_AHBPeriphClockCmd
              8 -> RCC_APB1PeriphClockCmd
              8 -> RCC_APB2PeriphClockCmd
       32  TIMER_Configuration
             32 -> GPIO_PinRemapConfig
             32 -> TIM_ARRPreloadConfig
             32 -> TIM_Cmd
             32 -> TIM_CtrlPWMOutputs
             32 -> TIM_OC3Init
             32 -> TIM_OC3PreloadConfig
             32 -> TIM_PrescalerConfig
             32 -> TIM_TimeBaseInit
        8  Time_Adjust
              8 -> RTC_SetCounter
              8 -> RTC_WaitForLastTask
              8 -> Time_Regulate
        4  Time_Regulate
       24  USART_Configuration
             24 -> USART_Cmd
             24 -> USART_ITConfig
             24 -> USART_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
     140  ADC_Config
     122  ADC_Configuration
     240  Acc_PwrEnterStandyMode
      48  Acc_Wdg_Config
       8  CAN_Configuration
      50  DAC_Config
       2  DMA_Configuration
      90  EXIT_Configuration
       2  EXIT_Control
       2  EXIT_all_off
       2  ExInt_Config
    1222  GPIO_Configuration
       2  GPIO_Off_Init
       2  GPIO_On_Init
       2  GPIO_keylight_Configuration
      92  I2C_Configuration
      46  MCU_Init
      22  Main_SysTick_Config
     172  NVIC_Configuration
      54  NVIC_STANBY_CAN_Configuration
      38  NVIC_SetPriority
      54  PWM_Configuration
     100  RCC_Close
     230  RCC_Configuration
     140  RTC_Configuration
       2  SPI_FLASH_Init
       2  STM32_Canbus_Config
      74  SYSCLKConfig_STOP
      56  SysTick_Config
     116  System_Normal_ClkSetup
     340  System_Standby_Reset_ClkSetup
     168  TIMER_Configuration
      20  Time_Adjust
      26  Time_Regulate
     260  USART_Configuration
       1  uPreMediaStatus
       1  uPrePreMediaStatus

 
     2 bytes in section .bss
 4 058 bytes in section .text
 
 4 058 bytes of CODE memory
     2 bytes of DATA memory

Errors: none
Warnings: none
