###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Jun/2016  13:18:47 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Libraries\STM32F10x_StdPeriph_Driver\src\stm #
#                    32f10x_can.c                                             #
#    Command line =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Libraries\STM32F10x_StdPeriph_Driver\src\stm #
#                    32f10x_can.c -D USE_STDPERIPH_DRIVER -D                  #
#                    USE_STM32100B_EVAL -D STM32F10X_CL -lc                   #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\ -lA F:\软件工程\平台正式代码001\Benze_MainBoa #
#                    rd\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_T #
#                    emplate\EWARM\Debug\List\ -o                             #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I F:\软件工程\平台正式代码001\Benze_MainBoard\ba #
#                    oma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Templa #
#                    te\EWARM\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\ -I F:\软件工程\平台正式代码001\Benze_Mai #
#                    nBoard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeri #
#                    ph_Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph #
#                    _Driver\inc\ -I F:\软件工程\平台正式代码001\Benze_MainBo #
#                    ard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_ #
#                    Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph_Dr #
#                    iver\src\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\..\..\Project/Common\ -I                  #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/TW8836\ -I F:\软件工程\平台正式代码001\B #
#                    enze_MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x #
#                    _StdPeriph_Template\EWARM\..\..\..\Project/CAN\ -I       #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/FM\ -I F:\软件工程\平台正式代码001\Benze #
#                    _MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x_Std #
#                    Periph_Template\EWARM\..\..\..\Project/ARM\ -I           #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\  #
#                    -On -I "C:\Program Files\IAR Systems\Embedded Workbench  #
#                    6.0_2\arm\CMSIS\Include\"                                #
#    List file    =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\stm32f10x_can.lst                              #
#    Object file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\Obj\stm32f10x_can.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\benci_newC_V45\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_can.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the CAN firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_can.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup CAN
     31            * @brief CAN driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup CAN_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup CAN_Private_Defines
     44            * @{
     45            */
     46          
     47          /* CAN Master Control Register bits */
     48          
     49          #define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
     50          
     51          /* CAN Mailbox Transmit Request */
     52          #define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
     53          
     54          /* CAN Filter Master Register bits */
     55          #define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */
     56          
     57          /* Time out for INAK bit */
     58          #define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)
     59          /* Time out for SLAK bit */
     60          #define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)
     61          
     62          
     63          
     64          /* Flags in TSR register */
     65          #define CAN_FLAGS_TSR              ((uint32_t)0x08000000)
     66          /* Flags in RF1R register */
     67          #define CAN_FLAGS_RF1R             ((uint32_t)0x04000000)
     68          /* Flags in RF0R register */
     69          #define CAN_FLAGS_RF0R             ((uint32_t)0x02000000)
     70          /* Flags in MSR register */
     71          #define CAN_FLAGS_MSR              ((uint32_t)0x01000000)
     72          /* Flags in ESR register */
     73          #define CAN_FLAGS_ESR              ((uint32_t)0x00F00000)
     74          
     75          /* Mailboxes definition */
     76          #define CAN_TXMAILBOX_0                   ((uint8_t)0x00)
     77          #define CAN_TXMAILBOX_1                   ((uint8_t)0x01)
     78          #define CAN_TXMAILBOX_2                   ((uint8_t)0x02)
     79          
     80          
     81          
     82          #define CAN_MODE_MASK              ((uint32_t) 0x00000003)
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup CAN_Private_Macros
     88            * @{
     89            */
     90          
     91          /**
     92            * @}
     93            */
     94          
     95          /** @defgroup CAN_Private_Variables
     96            * @{
     97            */
     98          
     99          /**
    100            * @}
    101            */
    102          
    103          /** @defgroup CAN_Private_FunctionPrototypes
    104            * @{
    105            */
    106          
    107          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    108          
    109          /**
    110            * @}
    111            */
    112          
    113          /** @defgroup CAN_Private_Functions
    114            * @{
    115            */
    116          
    117          /**
    118            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    119            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    120            * @retval None.
    121            */
    122          void CAN_DeInit(CAN_TypeDef *CANx)
    123          {
    124              /* Check the parameters */
    125              assert_param(IS_CAN_ALL_PERIPH(CANx));
    126          
    127              if (CANx == CAN1)
    128              {
    129                  /* Enable CAN1 reset state */
    130                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
    131                  /* Release CAN1 from reset state */
    132                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
    133              }
    134              else
    135              {
    136                  /* Enable CAN2 reset state */
    137                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    138                  /* Release CAN2 from reset state */
    139                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
    140              }
    141          }
    142          
    143          /**
    144            * @brief  Initializes the CAN peripheral according to the specified
    145            *         parameters in the CAN_InitStruct.
    146            * @param  CANx:           where x can be 1 or 2 to to select the CAN
    147            *                         peripheral.
    148            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
    149            *                         contains the configuration information for the
    150            *                         CAN peripheral.
    151            * @retval Constant indicates initialization succeed which will be
    152            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    153            */
    154          uint8_t CAN_Init(CAN_TypeDef *CANx, CAN_InitTypeDef *CAN_InitStruct)
    155          {
    156              uint8_t InitStatus = CAN_InitStatus_Failed;
    157              uint32_t wait_ack = 0x00000000;
    158              /* Check the parameters */
    159              assert_param(IS_CAN_ALL_PERIPH(CANx));
    160              assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    161              assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    162              assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    163              assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    164              assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    165              assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    166              assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    167              assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    168              assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    169              assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    170              assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    171          
    172              /* Exit from sleep mode */
    173              CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
    174          
    175              /* Request initialisation */
    176              CANx->MCR |= CAN_MCR_INRQ ;
    177          
    178              /* Wait the acknowledge */
    179              while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    180              {
    181                  wait_ack++;
    182              }
    183          
    184              /* Check acknowledge */
    185              if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
    186              {
    187                  InitStatus = CAN_InitStatus_Failed;
    188              }
    189              else
    190              {
    191                  /* Set the time triggered communication mode */
    192                  if (CAN_InitStruct->CAN_TTCM == ENABLE)
    193                  {
    194                      CANx->MCR |= CAN_MCR_TTCM;
    195                  }
    196                  else
    197                  {
    198                      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
    199                  }
    200          
    201                  /* Set the automatic bus-off management */
    202                  if (CAN_InitStruct->CAN_ABOM == ENABLE)
    203                  {
    204                      CANx->MCR |= CAN_MCR_ABOM;
    205                  }
    206                  else
    207                  {
    208                      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
    209                  }
    210          
    211                  /* Set the automatic wake-up mode */
    212                  if (CAN_InitStruct->CAN_AWUM == ENABLE)
    213                  {
    214                      CANx->MCR |= CAN_MCR_AWUM;
    215                  }
    216                  else
    217                  {
    218                      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
    219                  }
    220          
    221                  /* Set the no automatic retransmission */
    222                  if (CAN_InitStruct->CAN_NART == ENABLE)
    223                  {
    224                      CANx->MCR |= CAN_MCR_NART;
    225                  }
    226                  else
    227                  {
    228                      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
    229                  }
    230          
    231                  /* Set the receive FIFO locked mode */
    232                  if (CAN_InitStruct->CAN_RFLM == ENABLE)
    233                  {
    234                      CANx->MCR |= CAN_MCR_RFLM;
    235                  }
    236                  else
    237                  {
    238                      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
    239                  }
    240          
    241                  /* Set the transmit FIFO priority */
    242                  if (CAN_InitStruct->CAN_TXFP == ENABLE)
    243                  {
    244                      CANx->MCR |= CAN_MCR_TXFP;
    245                  }
    246                  else
    247                  {
    248                      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    249                  }
    250          
    251                  /* Set the bit timing register */
    252                  CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    253                              ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    254                              ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    255                              ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    256                              ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
    257          
    258                  /* Request leave initialisation */
    259                  CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
    260          
    261                  /* Wait the acknowledge */
    262                  wait_ack = 0;
    263          
    264                  while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    265                  {
    266                      wait_ack++;
    267                  }
    268          
    269                  /* ...and check acknowledged */
    270                  if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    271                  {
    272                      InitStatus = CAN_InitStatus_Failed;
    273                  }
    274                  else
    275                  {
    276                      InitStatus = CAN_InitStatus_Success ;
    277                  }
    278              }
    279          
    280              /* At this step, return the status of initialization */
    281              return InitStatus;
    282          }
    283          
    284          /**
    285            * @brief  Initializes the CAN peripheral according to the specified
    286            *         parameters in the CAN_FilterInitStruct.
    287            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
    288            *                               structure that contains the configuration
    289            *                               information.
    290            * @retval None.
    291            */
    292          void CAN_FilterInit(CAN_FilterInitTypeDef *CAN_FilterInitStruct)
    293          {
    294              uint32_t filter_number_bit_pos = 0;
    295              /* Check the parameters */
    296              assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    297              assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    298              assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    299              assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    300              assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    301          
    302              filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
    303          
    304              /* Initialisation mode for the filter */
    305              CAN1->FMR |= FMR_FINIT;
    306          
    307              /* Filter Deactivation */
    308              CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
    309          
    310              /* Filter Scale */
    311              if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    312              {
    313                  /* 16-bit scale for the filter */
    314                  CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
    315          
    316                  /* First 16-bit identifier and First 16-bit mask */
    317                  /* Or First 16-bit identifier and Second 16-bit identifier */
    318                  CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 =
    319                      ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    320                      (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    321          
    322                  /* Second 16-bit identifier and Second 16-bit mask */
    323                  /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    324                  CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 =
    325                      ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    326                      (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
    327              }
    328          
    329              if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    330              {
    331                  /* 32-bit scale for the filter */
    332                  CAN1->FS1R |= filter_number_bit_pos;
    333                  /* 32-bit identifier or First 32-bit identifier */
    334                  CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 =
    335                      ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    336                      (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    337                  /* 32-bit mask or Second 32-bit identifier */
    338                  CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 =
    339                      ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    340                      (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
    341              }
    342          
    343              /* Filter Mode */
    344              if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    345              {
    346                  /*Id/Mask mode for the filter*/
    347                  CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
    348              }
    349              else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    350              {
    351                  /*Identifier list mode for the filter*/
    352                  CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
    353              }
    354          
    355              /* Filter FIFO assignment */
    356              if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
    357              {
    358                  /* FIFO 0 assignation for the filter */
    359                  CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
    360              }
    361          
    362              if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
    363              {
    364                  /* FIFO 1 assignation for the filter */
    365                  CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
    366              }
    367          
    368              /* Filter activation */
    369              if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    370              {
    371                  CAN1->FA1R |= filter_number_bit_pos;
    372              }
    373          
    374              /* Leave the initialisation mode for the filter */
    375              CAN1->FMR &= ~FMR_FINIT;
    376          }
    377          
    378          /**
    379            * @brief  Fills each CAN_InitStruct member with its default value.
    380            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
    381            *                         will be initialized.
    382            * @retval None.
    383            */
    384          void CAN_StructInit(CAN_InitTypeDef *CAN_InitStruct)
    385          {
    386              /* Reset CAN init structure parameters values */
    387          
    388              /* Initialize the time triggered communication mode */
    389              CAN_InitStruct->CAN_TTCM = DISABLE;
    390          
    391              /* Initialize the automatic bus-off management */
    392              CAN_InitStruct->CAN_ABOM = DISABLE;
    393          
    394              /* Initialize the automatic wake-up mode */
    395              CAN_InitStruct->CAN_AWUM = DISABLE;
    396          
    397              /* Initialize the no automatic retransmission */
    398              CAN_InitStruct->CAN_NART = DISABLE;
    399          
    400              /* Initialize the receive FIFO locked mode */
    401              CAN_InitStruct->CAN_RFLM = DISABLE;
    402          
    403              /* Initialize the transmit FIFO priority */
    404              CAN_InitStruct->CAN_TXFP = DISABLE;
    405          
    406              /* Initialize the CAN_Mode member */
    407              CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    408          
    409              /* Initialize the CAN_SJW member */
    410              CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    411          
    412              /* Initialize the CAN_BS1 member */
    413              CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    414          
    415              /* Initialize the CAN_BS2 member */
    416              CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    417          
    418              /* Initialize the CAN_Prescaler member */
    419              CAN_InitStruct->CAN_Prescaler = 1;
    420          }
    421          
    422          /**
    423            * @brief  Select the start bank filter for slave CAN.
    424            * @note   This function applies only to STM32 Connectivity line devices.
    425            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    426            * @retval None.
    427            */
    428          void CAN_SlaveStartBank(uint8_t CAN_BankNumber)
    429          {
    430              /* Check the parameters */
    431              assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    432          
    433              /* Enter Initialisation mode for the filter */
    434              CAN1->FMR |= FMR_FINIT;
    435          
    436              /* Select the start slave bank */
    437              CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
    438              CAN1->FMR |= (uint32_t)(CAN_BankNumber) << 8;
    439          
    440              /* Leave Initialisation mode for the filter */
    441              CAN1->FMR &= ~FMR_FINIT;
    442          }
    443          
    444          /**
    445            * @brief  Enables or disables the DBG Freeze for CAN.
    446            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
    447            * @param  NewState: new state of the CAN peripheral. This parameter can
    448            *                   be: ENABLE or DISABLE.
    449            * @retval None.
    450            */
    451          void CAN_DBGFreeze(CAN_TypeDef *CANx, FunctionalState NewState)
    452          {
    453              /* Check the parameters */
    454              assert_param(IS_CAN_ALL_PERIPH(CANx));
    455              assert_param(IS_FUNCTIONAL_STATE(NewState));
    456          
    457              if (NewState != DISABLE)
    458              {
    459                  /* Enable Debug Freeze  */
    460                  CANx->MCR |= MCR_DBF;
    461              }
    462              else
    463              {
    464                  /* Disable Debug Freeze */
    465                  CANx->MCR &= ~MCR_DBF;
    466              }
    467          }
    468          
    469          
    470          /**
    471            * @brief  Enables or disabes the CAN Time TriggerOperation communication mode.
    472            * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
    473            * @param  NewState : Mode new state , can be one of @ref FunctionalState.
    474            * @note   when enabled, Time stamp (TIME[15:0]) value is sent in the last
    475            *         two data bytes of the 8-byte message: TIME[7:0] in data byte 6
    476            *         and TIME[15:8] in data byte 7
    477            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be
    478            *         sent over the CAN bus.
    479            * @retval None
    480            */
    481          void CAN_TTComModeCmd(CAN_TypeDef *CANx, FunctionalState NewState)
    482          {
    483              /* Check the parameters */
    484              assert_param(IS_CAN_ALL_PERIPH(CANx));
    485              assert_param(IS_FUNCTIONAL_STATE(NewState));
    486              if (NewState != DISABLE)
    487              {
    488                  /* Enable the TTCM mode */
    489                  CANx->MCR |= CAN_MCR_TTCM;
    490          
    491                  /* Set TGT bits */
    492                  CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
    493                  CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
    494                  CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
    495              }
    496              else
    497              {
    498                  /* Disable the TTCM mode */
    499                  CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
    500          
    501                  /* Reset TGT bits */
    502                  CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    503                  CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    504                  CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
    505              }
    506          }
    507          /**
    508            * @brief  Initiates the transmission of a message.
    509            * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
    510            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN
    511            *                    DLC and CAN data.
    512            * @retval The number of the mailbox that is used for transmission
    513            *                    or CAN_TxStatus_NoMailBox if there is no empty mailbox.
    514            */
    515          uint8_t CAN_Transmit(CAN_TypeDef *CANx, CanTxMsg *TxMessage)
    516          {
    517              uint8_t transmit_mailbox = 0;
    518              /* Check the parameters */
    519              assert_param(IS_CAN_ALL_PERIPH(CANx));
    520              assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    521              assert_param(IS_CAN_RTR(TxMessage->RTR));
    522              assert_param(IS_CAN_DLC(TxMessage->DLC));
    523          
    524              /* Select one empty transmit mailbox */
    525              if ((CANx->TSR & CAN_TSR_TME0) == CAN_TSR_TME0)
    526              {
    527                  transmit_mailbox = 0;
    528              }
    529              else if ((CANx->TSR & CAN_TSR_TME1) == CAN_TSR_TME1)
    530              {
    531                  transmit_mailbox = 1;
    532              }
    533              else if ((CANx->TSR & CAN_TSR_TME2) == CAN_TSR_TME2)
    534              {
    535                  transmit_mailbox = 2;
    536              }
    537              else
    538              {
    539                  transmit_mailbox = CAN_TxStatus_NoMailBox;
    540              }
    541          
    542              if (transmit_mailbox != CAN_TxStatus_NoMailBox)
    543              {
    544                  /* Set up the Id */
    545                  CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    546                  if (TxMessage->IDE == CAN_Id_Standard)
    547                  {
    548                      assert_param(IS_CAN_STDID(TxMessage->StdId));
    549                      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    550                              TxMessage->RTR);
    551                  }
    552                  else
    553                  {
    554                      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    555                      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    556                              TxMessage->IDE | \
    557                              TxMessage->RTR);
    558                  }
    559          
    560                  /* Set up the DLC */
    561                  TxMessage->DLC &= (uint8_t)0x0000000F;
    562                  CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    563                  CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
    564          
    565                  /* Set up the data field */
    566                  CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) |
    567                          ((uint32_t)TxMessage->Data[2] << 16) |
    568                          ((uint32_t)TxMessage->Data[1] << 8) |
    569                          ((uint32_t)TxMessage->Data[0]));
    570                  CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) |
    571                          ((uint32_t)TxMessage->Data[6] << 16) |
    572                          ((uint32_t)TxMessage->Data[5] << 8) |
    573                          ((uint32_t)TxMessage->Data[4]));
    574                  /* Request transmission */
    575                  CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
    576              }
    577              return transmit_mailbox;
    578          }
    579          
    580          /**
    581            * @brief  Checks the transmission of a message.
    582            * @param  CANx:            where x can be 1 or 2 to to select the
    583            *                          CAN peripheral.
    584            * @param  TransmitMailbox: the number of the mailbox that is used for
    585            *                          transmission.
    586            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, CAN_TxStatus_Failed
    587            *         in an other case.
    588            */
    589          uint8_t CAN_TransmitStatus(CAN_TypeDef *CANx, uint8_t TransmitMailbox)
    590          {
    591              uint32_t state = 0;
    592          
    593              /* Check the parameters */
    594              assert_param(IS_CAN_ALL_PERIPH(CANx));
    595              assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    596          
    597              switch (TransmitMailbox)
    598              {
    599              case (CAN_TXMAILBOX_0):
    600                  state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
    601                  break;
    602              case (CAN_TXMAILBOX_1):
    603                  state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
    604                  break;
    605              case (CAN_TXMAILBOX_2):
    606                  state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
    607                  break;
    608              default:
    609                  state = CAN_TxStatus_Failed;
    610                  break;
    611              }
    612              switch (state)
    613              {
    614                  /* transmit pending  */
    615              case (0x0):
    616                  state = CAN_TxStatus_Pending;
    617                  break;
    618                  /* transmit failed  */
    619              case (CAN_TSR_RQCP0 | CAN_TSR_TME0):
    620                  state = CAN_TxStatus_Failed;
    621                  break;
    622              case (CAN_TSR_RQCP1 | CAN_TSR_TME1):
    623                  state = CAN_TxStatus_Failed;
    624                  break;
    625              case (CAN_TSR_RQCP2 | CAN_TSR_TME2):
    626                  state = CAN_TxStatus_Failed;
    627                  break;
    628                  /* transmit succeeded  */
    629              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):
    630                  state = CAN_TxStatus_Ok;
    631                  break;
    632              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):
    633                  state = CAN_TxStatus_Ok;
    634                  break;
    635              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):
    636                  state = CAN_TxStatus_Ok;
    637                  break;
    638              default:
    639                  state = CAN_TxStatus_Failed;
    640                  break;
    641              }
    642              return (uint8_t) state;
    643          }
    644          
    645          /**
    646            * @brief  Cancels a transmit request.
    647            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
    648            * @param  Mailbox:  Mailbox number.
    649            * @retval None.
    650            */
    651          void CAN_CancelTransmit(CAN_TypeDef *CANx, uint8_t Mailbox)
    652          {
    653              /* Check the parameters */
    654              assert_param(IS_CAN_ALL_PERIPH(CANx));
    655              assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    656              /* abort transmission */
    657              switch (Mailbox)
    658              {
    659              case (CAN_TXMAILBOX_0):
    660                  CANx->TSR |= CAN_TSR_ABRQ0;
    661                  break;
    662              case (CAN_TXMAILBOX_1):
    663                  CANx->TSR |= CAN_TSR_ABRQ1;
    664                  break;
    665              case (CAN_TXMAILBOX_2):
    666                  CANx->TSR |= CAN_TSR_ABRQ2;
    667                  break;
    668              default:
    669                  break;
    670              }
    671          }
    672          
    673          
    674          /**
    675            * @brief  Receives a message.
    676            * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
    677            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    678            * @param  RxMessage:  pointer to a structure receive message which contains
    679            *                     CAN Id, CAN DLC, CAN datas and FMI number.
    680            * @retval None.
    681            */
    682          void CAN_Receive(CAN_TypeDef *CANx, uint8_t FIFONumber, CanRxMsg *RxMessage)
    683          {
    684              /* Check the parameters */
    685              assert_param(IS_CAN_ALL_PERIPH(CANx));
    686              assert_param(IS_CAN_FIFO(FIFONumber));
    687              /* Get the Id */
    688              RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
    689              if (RxMessage->IDE == CAN_Id_Standard)
    690              {
    691                  RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
    692              }
    693              else
    694              {
    695                  RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
    696              }
    697          
    698              RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
    699              /* Get the DLC */
    700              RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
    701              /* Get the FMI */
    702              RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
    703              /* Get the data field */
    704              RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
    705              RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
    706              RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
    707              RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
    708              RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
    709              RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
    710              RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
    711              RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
    712              /* Release the FIFO */
    713              /* Release FIFO0 */
    714              if (FIFONumber == CAN_FIFO0)
    715              {
    716                  CANx->RF0R |= CAN_RF0R_RFOM0;
    717              }
    718              /* Release FIFO1 */
    719              else /* FIFONumber == CAN_FIFO1 */
    720              {
    721                  CANx->RF1R |= CAN_RF1R_RFOM1;
    722              }
    723          }
    724          
    725          /**
    726            * @brief  Releases the specified FIFO.
    727            * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
    728            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    729            * @retval None.
    730            */
    731          void CAN_FIFORelease(CAN_TypeDef *CANx, uint8_t FIFONumber)
    732          {
    733              /* Check the parameters */
    734              assert_param(IS_CAN_ALL_PERIPH(CANx));
    735              assert_param(IS_CAN_FIFO(FIFONumber));
    736              /* Release FIFO0 */
    737              if (FIFONumber == CAN_FIFO0)
    738              {
    739                  CANx->RF0R |= CAN_RF0R_RFOM0;
    740              }
    741              /* Release FIFO1 */
    742              else /* FIFONumber == CAN_FIFO1 */
    743              {
    744                  CANx->RF1R |= CAN_RF1R_RFOM1;
    745              }
    746          }
    747          
    748          /**
    749            * @brief  Returns the number of pending messages.
    750            * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
    751            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    752            * @retval NbMessage : which is the number of pending message.
    753            */
    754          uint8_t CAN_MessagePending(CAN_TypeDef *CANx, uint8_t FIFONumber)
    755          {
    756              uint8_t message_pending = 0;
    757              /* Check the parameters */
    758              assert_param(IS_CAN_ALL_PERIPH(CANx));
    759              assert_param(IS_CAN_FIFO(FIFONumber));
    760              if (FIFONumber == CAN_FIFO0)
    761              {
    762                  message_pending = (uint8_t)(CANx->RF0R & (uint32_t)0x03);
    763              }
    764              else if (FIFONumber == CAN_FIFO1)
    765              {
    766                  message_pending = (uint8_t)(CANx->RF1R & (uint32_t)0x03);
    767              }
    768              else
    769              {
    770                  message_pending = 0;
    771              }
    772              return message_pending;
    773          }
    774          
    775          
    776          /**
    777            * @brief   Select the CAN Operation mode.
    778            * @param CAN_OperatingMode : CAN Operating Mode. This parameter can be one
    779            *                            of @ref CAN_OperatingMode_TypeDef enumeration.
    780            * @retval status of the requested mode which can be
    781            *         - CAN_ModeStatus_Failed    CAN failed entering the specific mode
    782            *         - CAN_ModeStatus_Success   CAN Succeed entering the specific mode
    783          
    784            */
    785          uint8_t CAN_OperatingModeRequest(CAN_TypeDef *CANx, uint8_t CAN_OperatingMode)
    786          {
    787              uint8_t status = CAN_ModeStatus_Failed;
    788          
    789              /* Timeout for INAK or also for SLAK bits*/
    790              uint32_t timeout = INAK_TIMEOUT;
    791          
    792              /* Check the parameters */
    793              assert_param(IS_CAN_ALL_PERIPH(CANx));
    794              assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    795          
    796              if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
    797              {
    798                  /* Request initialisation */
    799                  CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
    800          
    801                  /* Wait the acknowledge */
    802                  while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    803                  {
    804                      timeout--;
    805                  }
    806                  if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
    807                  {
    808                      status = CAN_ModeStatus_Failed;
    809                  }
    810                  else
    811                  {
    812                      status = CAN_ModeStatus_Success;
    813                  }
    814              }
    815              else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
    816              {
    817                  /* Request leave initialisation and sleep mode  and enter Normal mode */
    818                  CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP | CAN_MCR_INRQ));
    819          
    820                  /* Wait the acknowledge */
    821                  while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout != 0))
    822                  {
    823                      timeout--;
    824                  }
    825                  if ((CANx->MSR & CAN_MODE_MASK) != 0)
    826                  {
    827                      status = CAN_ModeStatus_Failed;
    828                  }
    829                  else
    830                  {
    831                      status = CAN_ModeStatus_Success;
    832                  }
    833              }
    834              else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
    835              {
    836                  /* Request Sleep mode */
    837                  CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    838          
    839                  /* Wait the acknowledge */
    840                  while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout != 0))
    841                  {
    842                      timeout--;
    843                  }
    844                  if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
    845                  {
    846                      status = CAN_ModeStatus_Failed;
    847                  }
    848                  else
    849                  {
    850                      status = CAN_ModeStatus_Success;
    851                  }
    852              }
    853              else
    854              {
    855                  status = CAN_ModeStatus_Failed;
    856              }
    857          
    858              return  (uint8_t) status;
    859          }
    860          
    861          /**
    862            * @brief  Enters the low power mode.
    863            * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
    864            * @retval status: CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed in an
    865            *                 other case.
    866            */
    867          uint8_t CAN_Sleep(CAN_TypeDef *CANx)
    868          {
    869              uint8_t sleepstatus = CAN_Sleep_Failed;
    870          
    871              /* Check the parameters */
    872              assert_param(IS_CAN_ALL_PERIPH(CANx));
    873          
    874              /* Request Sleep mode */
    875              CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    876          
    877              /* Sleep mode status */
    878              if ((CANx->MSR & (CAN_MSR_SLAK | CAN_MSR_INAK)) == CAN_MSR_SLAK)
    879              {
    880                  /* Sleep mode not entered */
    881                  sleepstatus =  CAN_Sleep_Ok;
    882              }
    883              /* return sleep mode status */
    884              return (uint8_t)sleepstatus;
    885          }
    886          
    887          /**
    888            * @brief  Wakes the CAN up.
    889            * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
    890            * @retval status:  CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed in an
    891            *                  other case.
    892            */
    893          uint8_t CAN_WakeUp(CAN_TypeDef *CANx)
    894          {
    895              uint32_t wait_slak = SLAK_TIMEOUT;
    896              uint8_t wakeupstatus = CAN_WakeUp_Failed;
    897          
    898              /* Check the parameters */
    899              assert_param(IS_CAN_ALL_PERIPH(CANx));
    900          
    901              /* Wake up request */
    902              CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
    903          
    904              /* Sleep mode status */
    905              while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK) && (wait_slak != 0x00))
    906              {
    907                  wait_slak--;
    908              }
    909              if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
    910              {
    911                  /* wake up done : Sleep mode exited */
    912                  wakeupstatus = CAN_WakeUp_Ok;
    913              }
    914              /* return wakeup status */
    915              return (uint8_t)wakeupstatus;
    916          }
    917          
    918          
    919          /**
    920            * @brief  Returns the CANx's last error code (LEC).
    921            * @param  CANx:          where x can be 1 or 2 to to select the CAN peripheral.
    922            * @retval CAN_ErrorCode: specifies the Error code :
    923            *                        - CAN_ERRORCODE_NoErr            No Error
    924            *                        - CAN_ERRORCODE_StuffErr         Stuff Error
    925            *                        - CAN_ERRORCODE_FormErr          Form Error
    926            *                        - CAN_ERRORCODE_ACKErr           Acknowledgment Error
    927            *                        - CAN_ERRORCODE_BitRecessiveErr  Bit Recessive Error
    928            *                        - CAN_ERRORCODE_BitDominantErr   Bit Dominant Error
    929            *                        - CAN_ERRORCODE_CRCErr           CRC Error
    930            *                        - CAN_ERRORCODE_SoftwareSetErr   Software Set Error
    931            */
    932          
    933          uint8_t CAN_GetLastErrorCode(CAN_TypeDef *CANx)
    934          {
    935              uint8_t errorcode = 0;
    936          
    937              /* Check the parameters */
    938              assert_param(IS_CAN_ALL_PERIPH(CANx));
    939          
    940              /* Get the error code*/
    941              errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
    942          
    943              /* Return the error code*/
    944              return errorcode;
    945          }
    946          /**
    947            * @brief  Returns the CANx Receive Error Counter (REC).
    948            * @note   In case of an error during reception, this counter is incremented
    949            *         by 1 or by 8 depending on the error condition as defined by the CAN
    950            *         standard. After every successful reception, the counter is
    951            *         decremented by 1 or reset to 120 if its value was higher than 128.
    952            *         When the counter value exceeds 127, the CAN controller enters the
    953            *         error passive state.
    954            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    955            * @retval CAN Receive Error Counter.
    956            */
    957          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef *CANx)
    958          {
    959              uint8_t counter = 0;
    960          
    961              /* Check the parameters */
    962              assert_param(IS_CAN_ALL_PERIPH(CANx));
    963          
    964              /* Get the Receive Error Counter*/
    965              counter = (uint8_t)((CANx->ESR & CAN_ESR_REC) >> 24);
    966          
    967              /* Return the Receive Error Counter*/
    968              return counter;
    969          }
    970          
    971          
    972          /**
    973            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
    974            * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
    975            * @retval LSB of the 9-bit CAN Transmit Error Counter.
    976            */
    977          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef *CANx)
    978          {
    979              uint8_t counter = 0;
    980          
    981              /* Check the parameters */
    982              assert_param(IS_CAN_ALL_PERIPH(CANx));
    983          
    984              /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
    985              counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC) >> 16);
    986          
    987              /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
    988              return counter;
    989          }
    990          
    991          
    992          /**
    993            * @brief  Enables or disables the specified CANx interrupts.
    994            * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
    995            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
    996            *                 This parameter can be:
    997            *                 - CAN_IT_TME,
    998            *                 - CAN_IT_FMP0,
    999            *                 - CAN_IT_FF0,
   1000            *                 - CAN_IT_FOV0,
   1001            *                 - CAN_IT_FMP1,
   1002            *                 - CAN_IT_FF1,
   1003            *                 - CAN_IT_FOV1,
   1004            *                 - CAN_IT_EWG,
   1005            *                 - CAN_IT_EPV,
   1006            *                 - CAN_IT_LEC,
   1007            *                 - CAN_IT_ERR,
   1008            *                 - CAN_IT_WKU or
   1009            *                 - CAN_IT_SLK.
   1010            * @param  NewState: new state of the CAN interrupts.
   1011            *                   This parameter can be: ENABLE or DISABLE.
   1012            * @retval None.
   1013            */
   1014          void CAN_ITConfig(CAN_TypeDef *CANx, uint32_t CAN_IT, FunctionalState NewState)
   1015          {
   1016              /* Check the parameters */
   1017              assert_param(IS_CAN_ALL_PERIPH(CANx));
   1018              assert_param(IS_CAN_IT(CAN_IT));
   1019              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1020          
   1021              if (NewState != DISABLE)
   1022              {
   1023                  /* Enable the selected CANx interrupt */
   1024                  CANx->IER |= CAN_IT;
   1025              }
   1026              else
   1027              {
   1028                  /* Disable the selected CANx interrupt */
   1029                  CANx->IER &= ~CAN_IT;
   1030              }
   1031          }
   1032          /**
   1033            * @brief  Checks whether the specified CAN flag is set or not.
   1034            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
   1035            * @param  CAN_FLAG: specifies the flag to check.
   1036            *                   This parameter can be one of the following flags:
   1037            *                  - CAN_FLAG_EWG
   1038            *                  - CAN_FLAG_EPV
   1039            *                  - CAN_FLAG_BOF
   1040            *                  - CAN_FLAG_RQCP0
   1041            *                  - CAN_FLAG_RQCP1
   1042            *                  - CAN_FLAG_RQCP2
   1043            *                  - CAN_FLAG_FMP1
   1044            *                  - CAN_FLAG_FF1
   1045            *                  - CAN_FLAG_FOV1
   1046            *                  - CAN_FLAG_FMP0
   1047            *                  - CAN_FLAG_FF0
   1048            *                  - CAN_FLAG_FOV0
   1049            *                  - CAN_FLAG_WKU
   1050            *                  - CAN_FLAG_SLAK
   1051            *                  - CAN_FLAG_LEC
   1052            * @retval The new state of CAN_FLAG (SET or RESET).
   1053            */
   1054          FlagStatus CAN_GetFlagStatus(CAN_TypeDef *CANx, uint32_t CAN_FLAG)
   1055          {
   1056              FlagStatus bitstatus = RESET;
   1057          
   1058              /* Check the parameters */
   1059              assert_param(IS_CAN_ALL_PERIPH(CANx));
   1060              assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1061          
   1062          
   1063              if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   1064              {
   1065                  /* Check the status of the specified CAN flag */
   1066                  if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1067                  {
   1068                      /* CAN_FLAG is set */
   1069                      bitstatus = SET;
   1070                  }
   1071                  else
   1072                  {
   1073                      /* CAN_FLAG is reset */
   1074                      bitstatus = RESET;
   1075                  }
   1076              }
   1077              else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   1078              {
   1079                  /* Check the status of the specified CAN flag */
   1080                  if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1081                  {
   1082                      /* CAN_FLAG is set */
   1083                      bitstatus = SET;
   1084                  }
   1085                  else
   1086                  {
   1087                      /* CAN_FLAG is reset */
   1088                      bitstatus = RESET;
   1089                  }
   1090              }
   1091              else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1092              {
   1093                  /* Check the status of the specified CAN flag */
   1094                  if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1095                  {
   1096                      /* CAN_FLAG is set */
   1097                      bitstatus = SET;
   1098                  }
   1099                  else
   1100                  {
   1101                      /* CAN_FLAG is reset */
   1102                      bitstatus = RESET;
   1103                  }
   1104              }
   1105              else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1106              {
   1107                  /* Check the status of the specified CAN flag */
   1108                  if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1109                  {
   1110                      /* CAN_FLAG is set */
   1111                      bitstatus = SET;
   1112                  }
   1113                  else
   1114                  {
   1115                      /* CAN_FLAG is reset */
   1116                      bitstatus = RESET;
   1117                  }
   1118              }
   1119              else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1120              {
   1121                  /* Check the status of the specified CAN flag */
   1122                  if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1123                  {
   1124                      /* CAN_FLAG is set */
   1125                      bitstatus = SET;
   1126                  }
   1127                  else
   1128                  {
   1129                      /* CAN_FLAG is reset */
   1130                      bitstatus = RESET;
   1131                  }
   1132              }
   1133              /* Return the CAN_FLAG status */
   1134              return  bitstatus;
   1135          }
   1136          
   1137          /**
   1138            * @brief  Clears the CAN's pending flags.
   1139            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
   1140            * @param  CAN_FLAG: specifies the flag to clear.
   1141            *                   This parameter can be one of the following flags:
   1142            *                    - CAN_FLAG_RQCP0
   1143            *                    - CAN_FLAG_RQCP1
   1144            *                    - CAN_FLAG_RQCP2
   1145            *                    - CAN_FLAG_FF1
   1146            *                    - CAN_FLAG_FOV1
   1147            *                    - CAN_FLAG_FF0
   1148            *                    - CAN_FLAG_FOV0
   1149            *                    - CAN_FLAG_WKU
   1150            *                    - CAN_FLAG_SLAK
   1151            *                    - CAN_FLAG_LEC
   1152            * @retval None.
   1153            */
   1154          void CAN_ClearFlag(CAN_TypeDef *CANx, uint32_t CAN_FLAG)
   1155          {
   1156              uint32_t flagtmp = 0;
   1157              /* Check the parameters */
   1158              assert_param(IS_CAN_ALL_PERIPH(CANx));
   1159              assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1160          
   1161              if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   1162              {
   1163                  /* Clear the selected CAN flags */
   1164                  CANx->ESR = (uint32_t)RESET;
   1165              }
   1166              else /* MSR or TSR or RF0R or RF1R */
   1167              {
   1168                  flagtmp = CAN_FLAG & 0x000FFFFF;
   1169          
   1170                  if ((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1171                  {
   1172                      /* Receive Flags */
   1173                      CANx->RF0R = (uint32_t)(flagtmp);
   1174                  }
   1175                  else if ((CAN_FLAG & CAN_FLAGS_RF1R) != (uint32_t)RESET)
   1176                  {
   1177                      /* Receive Flags */
   1178                      CANx->RF1R = (uint32_t)(flagtmp);
   1179                  }
   1180                  else if ((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1181                  {
   1182                      /* Transmit Flags */
   1183                      CANx->TSR = (uint32_t)(flagtmp);
   1184                  }
   1185                  else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1186                  {
   1187                      /* Operating mode Flags */
   1188                      CANx->MSR = (uint32_t)(flagtmp);
   1189                  }
   1190              }
   1191          }
   1192          
   1193          /**
   1194            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1195            * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
   1196            * @param  CAN_IT:  specifies the CAN interrupt source to check.
   1197            *                  This parameter can be one of the following flags:
   1198            *                 -  CAN_IT_TME
   1199            *                 -  CAN_IT_FMP0
   1200            *                 -  CAN_IT_FF0
   1201            *                 -  CAN_IT_FOV0
   1202            *                 -  CAN_IT_FMP1
   1203            *                 -  CAN_IT_FF1
   1204            *                 -  CAN_IT_FOV1
   1205            *                 -  CAN_IT_WKU
   1206            *                 -  CAN_IT_SLK
   1207            *                 -  CAN_IT_EWG
   1208            *                 -  CAN_IT_EPV
   1209            *                 -  CAN_IT_BOF
   1210            *                 -  CAN_IT_LEC
   1211            *                 -  CAN_IT_ERR
   1212            * @retval The current state of CAN_IT (SET or RESET).
   1213            */
   1214          ITStatus CAN_GetITStatus(CAN_TypeDef *CANx, uint32_t CAN_IT)
   1215          {
   1216              ITStatus itstatus = RESET;
   1217              /* Check the parameters */
   1218              assert_param(IS_CAN_ALL_PERIPH(CANx));
   1219              assert_param(IS_CAN_IT(CAN_IT));
   1220          
   1221              /* check the enable interrupt bit */
   1222              if((CANx->IER & CAN_IT) != RESET)
   1223              {
   1224                  /* in case the Interrupt is enabled, .... */
   1225                  switch (CAN_IT)
   1226                  {
   1227                  case CAN_IT_TME:
   1228                      /* Check CAN_TSR_RQCPx bits */
   1229                      itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2);
   1230                      break;
   1231                  case CAN_IT_FMP0:
   1232                      /* Check CAN_RF0R_FMP0 bit */
   1233                      itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);
   1234                      break;
   1235                  case CAN_IT_FF0:
   1236                      /* Check CAN_RF0R_FULL0 bit */
   1237                      itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);
   1238                      break;
   1239                  case CAN_IT_FOV0:
   1240                      /* Check CAN_RF0R_FOVR0 bit */
   1241                      itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);
   1242                      break;
   1243                  case CAN_IT_FMP1:
   1244                      /* Check CAN_RF1R_FMP1 bit */
   1245                      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);
   1246                      break;
   1247                  case CAN_IT_FF1:
   1248                      /* Check CAN_RF1R_FULL1 bit */
   1249                      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);
   1250                      break;
   1251                  case CAN_IT_FOV1:
   1252                      /* Check CAN_RF1R_FOVR1 bit */
   1253                      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);
   1254                      break;
   1255                  case CAN_IT_WKU:
   1256                      /* Check CAN_MSR_WKUI bit */
   1257                      itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);
   1258                      break;
   1259                  case CAN_IT_SLK:
   1260                      /* Check CAN_MSR_SLAKI bit */
   1261                      itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);
   1262                      break;
   1263                  case CAN_IT_EWG:
   1264                      /* Check CAN_ESR_EWGF bit */
   1265                      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);
   1266                      break;
   1267                  case CAN_IT_EPV:
   1268                      /* Check CAN_ESR_EPVF bit */
   1269                      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);
   1270                      break;
   1271                  case CAN_IT_BOF:
   1272                      /* Check CAN_ESR_BOFF bit */
   1273                      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);
   1274                      break;
   1275                  case CAN_IT_LEC:
   1276                      /* Check CAN_ESR_LEC bit */
   1277                      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);
   1278                      break;
   1279                  case CAN_IT_ERR:
   1280                      /* Check CAN_MSR_ERRI bit */
   1281                      itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI);
   1282                      break;
   1283                  default :
   1284                      /* in case of error, return RESET */
   1285                      itstatus = RESET;
   1286                      break;
   1287                  }
   1288              }
   1289              else
   1290              {
   1291                  /* in case the Interrupt is not enabled, return RESET */
   1292                  itstatus  = RESET;
   1293              }
   1294          
   1295              /* Return the CAN_IT status */
   1296              return  itstatus;
   1297          }
   1298          
   1299          /**
   1300            * @brief  Clears the CANx's interrupt pending bits.
   1301            * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
   1302            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1303            *                  -  CAN_IT_TME
   1304            *                  -  CAN_IT_FF0
   1305            *                  -  CAN_IT_FOV0
   1306            *                  -  CAN_IT_FF1
   1307            *                  -  CAN_IT_FOV1
   1308            *                  -  CAN_IT_WKU
   1309            *                  -  CAN_IT_SLK
   1310            *                  -  CAN_IT_EWG
   1311            *                  -  CAN_IT_EPV
   1312            *                  -  CAN_IT_BOF
   1313            *                  -  CAN_IT_LEC
   1314            *                  -  CAN_IT_ERR
   1315            * @retval None.
   1316            */
   1317          void CAN_ClearITPendingBit(CAN_TypeDef *CANx, uint32_t CAN_IT)
   1318          {
   1319              /* Check the parameters */
   1320              assert_param(IS_CAN_ALL_PERIPH(CANx));
   1321              assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1322          
   1323              switch (CAN_IT)
   1324              {
   1325              case CAN_IT_TME:
   1326                  /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1327                  CANx->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
   1328                  break;
   1329              case CAN_IT_FF0:
   1330                  /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1331                  CANx->RF0R = CAN_RF0R_FULL0;
   1332                  break;
   1333              case CAN_IT_FOV0:
   1334                  /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1335                  CANx->RF0R = CAN_RF0R_FOVR0;
   1336                  break;
   1337              case CAN_IT_FF1:
   1338                  /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1339                  CANx->RF1R = CAN_RF1R_FULL1;
   1340                  break;
   1341              case CAN_IT_FOV1:
   1342                  /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1343                  CANx->RF1R = CAN_RF1R_FOVR1;
   1344                  break;
   1345              case CAN_IT_WKU:
   1346                  /* Clear CAN_MSR_WKUI (rc_w1)*/
   1347                  CANx->MSR = CAN_MSR_WKUI;
   1348                  break;
   1349              case CAN_IT_SLK:
   1350                  /* Clear CAN_MSR_SLAKI (rc_w1)*/
   1351                  CANx->MSR = CAN_MSR_SLAKI;
   1352                  break;
   1353              case CAN_IT_EWG:
   1354                  /* Clear CAN_MSR_ERRI (rc_w1) */
   1355                  CANx->MSR = CAN_MSR_ERRI;
   1356                  /* Note : the corresponding Flag is cleared by hardware depending
   1357                            of the CAN Bus status*/
   1358                  break;
   1359              case CAN_IT_EPV:
   1360                  /* Clear CAN_MSR_ERRI (rc_w1) */
   1361                  CANx->MSR = CAN_MSR_ERRI;
   1362                  /* Note : the corresponding Flag is cleared by hardware depending
   1363                            of the CAN Bus status*/
   1364                  break;
   1365              case CAN_IT_BOF:
   1366                  /* Clear CAN_MSR_ERRI (rc_w1) */
   1367                  CANx->MSR = CAN_MSR_ERRI;
   1368                  /* Note : the corresponding Flag is cleared by hardware depending
   1369                            of the CAN Bus status*/
   1370                  break;
   1371              case CAN_IT_LEC:
   1372                  /*  Clear LEC bits */
   1373                  CANx->ESR = RESET;
   1374                  /* Clear CAN_MSR_ERRI (rc_w1) */
   1375                  CANx->MSR = CAN_MSR_ERRI;
   1376                  break;
   1377              case CAN_IT_ERR:
   1378                  /*Clear LEC bits */
   1379                  CANx->ESR = RESET;
   1380                  /* Clear CAN_MSR_ERRI (rc_w1) */
   1381                  CANx->MSR = CAN_MSR_ERRI;
   1382                  /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending
   1383                          of the CAN Bus status*/
   1384                  break;
   1385              default :
   1386                  break;
   1387              }
   1388          }
   1389          
   1390          /**
   1391            * @brief  Checks whether the CAN interrupt has occurred or not.
   1392            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1393            * @param  It_Bit:  specifies the interrupt source bit to check.
   1394            * @retval The new state of the CAN Interrupt (SET or RESET).
   1395            */
   1396          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1397          {
   1398              ITStatus pendingbitstatus = RESET;
   1399          
   1400              if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   1401              {
   1402                  /* CAN_IT is set */
   1403                  pendingbitstatus = SET;
   1404              }
   1405              else
   1406              {
   1407                  /* CAN_IT is reset */
   1408                  pendingbitstatus = RESET;
   1409              }
   1410              return pendingbitstatus;
   1411          }
   1412          
   1413          
   1414          /**
   1415            * @}
   1416            */
   1417          
   1418          /**
   1419            * @}
   1420            */
   1421          
   1422          /**
   1423            * @}
   1424            */
   1425          
   1426          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  CAN_CancelTransmit
        0  CAN_ClearFlag
        0  CAN_ClearITPendingBit
        0  CAN_DBGFreeze
        8  CAN_DeInit
              8 -> RCC_APB1PeriphResetCmd
        0  CAN_FIFORelease
        4  CAN_FilterInit
        0  CAN_GetFlagStatus
       16  CAN_GetITStatus
             16 -> CheckITStatus
        0  CAN_GetLSBTransmitErrorCounter
        0  CAN_GetLastErrorCode
        0  CAN_GetReceiveErrorCounter
        0  CAN_ITConfig
        8  CAN_Init
        0  CAN_MessagePending
        4  CAN_OperatingModeRequest
        0  CAN_Receive
        0  CAN_SlaveStartBank
        0  CAN_Sleep
        0  CAN_StructInit
        0  CAN_TTComModeCmd
        8  CAN_Transmit
        4  CAN_TransmitStatus
        0  CAN_WakeUp
        0  CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      46  CAN_CancelTransmit
      48  CAN_ClearFlag
     148  CAN_ClearITPendingBit
      26  CAN_DBGFreeze
      56  CAN_DeInit
      26  CAN_FIFORelease
     274  CAN_FilterInit
     124  CAN_GetFlagStatus
     272  CAN_GetITStatus
      14  CAN_GetLSBTransmitErrorCounter
      16  CAN_GetLastErrorCode
      14  CAN_GetReceiveErrorCounter
      22  CAN_ITConfig
     280  CAN_Init
      44  CAN_MessagePending
     190  CAN_OperatingModeRequest
     232  CAN_Receive
      70  CAN_SlaveStartBank
      34  CAN_Sleep
      46  CAN_StructInit
     104  CAN_TTComModeCmd
     294  CAN_Transmit
     164  CAN_TransmitStatus
      44  CAN_WakeUp
      22  CheckITStatus

 
 2 674 bytes in section .text
 
 2 674 bytes of CODE memory

Errors: none
Warnings: none
