###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Jun/2016  13:18:49 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\stm32f1 #
#                    0x_it.c                                                  #
#    Command line =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\stm32f1 #
#                    0x_it.c -D USE_STDPERIPH_DRIVER -D USE_STM32100B_EVAL    #
#                    -D STM32F10X_CL -lc F:\软件工程\平台正式代码001\Benze_Ma #
#                    inBoard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPer #
#                    iph_Template\EWARM\Debug\List\ -lA                       #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\ -o F:\软件工程\平台正式代码001\Benze_MainBoar #
#                    d\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Te #
#                    mplate\EWARM\Debug\Obj\ --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I F:\软件工程\平台正式代码001\Benze_MainBoard\ba #
#                    oma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Templa #
#                    te\EWARM\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\ -I F:\软件工程\平台正式代码001\Benze_Mai #
#                    nBoard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeri #
#                    ph_Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph #
#                    _Driver\inc\ -I F:\软件工程\平台正式代码001\Benze_MainBo #
#                    ard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_ #
#                    Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph_Dr #
#                    iver\src\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\..\..\Project/Common\ -I                  #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/TW8836\ -I F:\软件工程\平台正式代码001\B #
#                    enze_MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x #
#                    _StdPeriph_Template\EWARM\..\..\..\Project/CAN\ -I       #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/FM\ -I F:\软件工程\平台正式代码001\Benze #
#                    _MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x_Std #
#                    Periph_Template\EWARM\..\..\..\Project/ARM\ -I           #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\  #
#                    -On -I "C:\Program Files\IAR Systems\Embedded Workbench  #
#                    6.0_2\arm\CMSIS\Include\"                                #
#    List file    =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\stm32f10x_it.lst                               #
#    Object file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\Obj\stm32f10x_it.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Template\stm32f10x_it.c
      1          /**
      2            ******************************************************************************
      3            * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    08-April-2011
      7            * @brief   Main Interrupt Service Routines.
      8            *          This file provides template for all exceptions handler and
      9            *          peripherals interrupt service routine.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     15            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     16            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     17            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     18            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19            *
     20            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     21            ******************************************************************************
     22            */
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "includes.h"
     26          u16 capture = 0;
     27          CanRxMsg g_RxMessage;
     28           //GPS_DATA g_GPS_DATA;
     29          /** @addtogroup STM32F10x_StdPeriph_Template
     30            * @{
     31            */
     32          
     33          /* Private typedef -----------------------------------------------------------*/
     34          /* Private define ------------------------------------------------------------*/
     35          /* Private macro -------------------------------------------------------------*/
     36          /* Private variables ---------------------------------------------------------*/
     37          /* Private function prototypes -----------------------------------------------*/
     38          /* Private functions ---------------------------------------------------------*/
     39          
     40          /******************************************************************************/
     41          /*            Cortex-M3 Processor Exceptions Handlers                         */
     42          /******************************************************************************/
     43          
     44          /**
     45            * @brief  This function handles NMI exception.
     46            * @param  None
     47            * @retval None
     48            */
     49          void NMI_Handler(void)
     50          {
     51          }
     52          
     53          /**
     54            * @brief  This function handles Hard Fault exception.
     55            * @param  None
     56            * @retval None
     57            */
     58          void HardFault_Handler(void)
     59          {
     60              /* Go to infinite loop when Hard Fault exception occurs */
     61              while (1)
     62              {
     63              }
     64          }
     65          
     66          /**
     67            * @brief  This function handles Memory Manage exception.
     68            * @param  None
     69            * @retval None
     70            */
     71          void MemManage_Handler(void)
     72          {
     73              /* Go to infinite loop when Memory Manage exception occurs */
     74              while (1)
     75              {
     76              }
     77          }
     78          
     79          /**
     80            * @brief  This function handles Bus Fault exception.
     81            * @param  None
     82            * @retval None
     83            */
     84          void BusFault_Handler(void)
     85          {
     86              /* Go to infinite loop when Bus Fault exception occurs */
     87              while (1)
     88              {
     89              }
     90          }
     91          
     92          /**
     93            * @brief  This function handles Usage Fault exception.
     94            * @param  None
     95            * @retval None
     96            */
     97          void UsageFault_Handler(void)
     98          {
     99              /* Go to infinite loop when Usage Fault exception occurs */
    100              while (1)
    101              {
    102              }
    103          }
    104          
    105          /**
    106            * @brief  This function handles SVCall exception.
    107            * @param  None
    108            * @retval None
    109            */
    110          void SVC_Handler(void)
    111          {
    112          }
    113          
    114          /**
    115            * @brief  This function handles Debug Monitor exception.
    116            * @param  None
    117            * @retval None
    118            */
    119          void DebugMon_Handler(void)
    120          {
    121          }
    122          
    123          /**
    124            * @brief  This function handles PendSVC exception.
    125            * @param  None
    126            * @retval None
    127            */
    128          void PendSV_Handler(void)
    129          {
    130          }
    131          
    132          /**
    133            * @brief  This function handles SysTick Handler.
    134            * @param  None
    135            * @retval None
    136            */
    137          void SysTick_Handler(void)
    138          {
    139              static vu16 u16MsCount = 0; //1ms
    140              static vu16 u10MsCount = 0; //1ms
    141              static vu16 u100MsClrWdgCount = 0; //100ms
    142              
    143             // BYTE uChecksum,i;
    144             	if(ARM_Max_Time_Cnt>0)
    145          	{
    146          		ARM_Max_Time_Cnt--;
    147          		if(ARM_Max_Time_Cnt==0)
    148          		{//-----------总线接收超时退出
    149          			ARM_Receive_Cnt=0;
    150          		}
    151          	}	
    152          	#if 0
    153          	if(ARM_send_id==0)
    154          	{
    155          		if(ARM_ack_request!=0)
    156          		{
    157          			ARM_Receive_ACK(ARM_ack_request);
    158          			ARM_ack_request=0;		
    159          		}
    160          	}
    161          	#endif
    162              u32Systick++;
    163              u10MsCount++;
    164              u100MsClrWdgCount++;
    165          #if 0
    166              if (u100MsClrWdgCount >= 100)
    167              {
    168          
    169                  u100MsClrWdgCount = 0;
    170                  //--------clear wdg timer----------------------------------
    171                  /* Reload IWDG counter */
    172                  IWDG_ReloadCounter();
    173              }
    174          #endif
    175              //------------------------------------------------------------
    176              //------------------------------------------------------------
    177              if(g_stuCurPower.wPowerWamkeupTimer != 0)g_stuCurPower.wPowerWamkeupTimer--;
    178              if(m_BMW_CAN.wLoopTimer != 0)m_BMW_CAN.wLoopTimer--;
    179          
    180              if(Sys.wPowerOnByCanTimer!=0)Sys.wPowerOnByCanTimer--;
    181              if(Sys.wPowerOnByCanTimer2!=0)Sys.wPowerOnByCanTimer2--;
    182              if(Sys.wKnobAuxContrlTimer!=0)Sys.wKnobAuxContrlTimer--;
    183              if(Sys.wRearOnByCanTimer!=0)Sys.wRearOnByCanTimer--;
    184          	
    185              if(m_CarDoorInfo.door_show_timer!=0)m_CarDoorInfo.door_show_timer--;
    186              if(Sys.WVedio_show_timer>1)Sys.WVedio_show_timer--;
    187          	
    188              if(m_BMW_CAN.benze_air_show_Timer!=0)m_BMW_CAN.benze_air_show_Timer--;
    189              if(g_GPS_DATA.RxFinishTimer!=0)g_GPS_DATA.RxFinishTimer--;
    190          	if(press_timer>1) press_timer--;
    191          	if(U8Tiemr_connect_press!=0) 
    192          		U8Tiemr_connect_press--;
    193          	else
    194          		connect_press_one=0;
    195          
    196          	 
    197          
    198          
    199               if(gNaviCnt!=0)gNaviCnt--;
    200          
    201          	 
    202          	Time_Bus_Cnt++;
    203          	
    204              if(Time_Bus_Cnt%2==0)
    205              {			
    206          		if(Time_Bus_Cnt%10==0)
    207          		{
    208          			Time_10ms_arrival=1;
    209          	
    210          
    211          			if(Time_Bus_Cnt%50==0)
    212          			{
    213          				Time_50ms_arrival=1;
    214          
    215          				BAT_Detect_Int();
    216          
    217          				//----------------------
    218          				if(Time_Bus_Cnt%100==0)
    219          				{
    220          					Time_100ms_arrival=1;
    221          
    222          
    223          					
    224          					if(Poweroff_init_count!=0)
    225          						Poweroff_init_count--;
    226          					if(Powerwork_init_count!=0)
    227          						Powerwork_init_count--;
    228          					if(Powerstany_count!=0)
    229          						Powerstany_count--;
    230          					if(Power_canbuswait_count!=0)
    231          						Power_canbuswait_count--;
    232          
    233          					if(Touch_valide_count)
    234          					    Touch_valide_count--;					
    235          
    236          
    237          					if(Time_Bus_Cnt%200==0)
    238          					{
    239          						Time_300ms_arrival=1;
    240          					}
    241          					
    242          					//------------------------
    243          					if(Time_Bus_Cnt%500==0)
    244          					{
    245          						Time_500ms_arrival=1;		
    246          
    247          	
    248          
    249          						if(ITL_DetectDelayCntr<8)		
    250          							ITL_DetectDelayCntr++;
    251          						
    252          						//-----------------------
    253          						if(Time_Bus_Cnt%1000==0)
    254          						{
    255          							Time_1s_arrival=1;
    256          							#if 1
    257          								{
    258          									if(IWDG_load_Count<3)
    259          										{
    260          							IWDG_ReloadCounter();
    261          							IWDG_load_Count++;
    262          										}
    263          								}
    264          							#endif
    265          
    266          							if(Time_Bus_Cnt%5000==0)
    267          							{
    268          								Time_5s_arrival=1;  	
    269          								if(Time_Bus_Cnt%(1000*60)==0)
    270          								{
    271          									Time_minute_arrival=1;  	
    272          								}
    273          							}
    274          							
    275          						}
    276          					}
    277          				}
    278          			}		
    279          		}
    280          	}
    281          
    282              //---------------------------------------
    283          
    284          }
    285          /******************************************************************************/
    286          /*            STM32F10x Peripherals Interrupt Handlers                        */
    287          /******************************************************************************/
    288          
    289          /**
    290            * @brief  This function handles TIM2 global interrupt request.
    291            * @param  None
    292            * @retval None
    293            */
    294          void TIM2_IRQHandler(void)
    295          {
    296              if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)
    297              {
    298                  TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
    299                  //ir
    300            
    301                  IN_MTN5_IRSendCodeTask();
    302                  
    303                  capture = TIM_GetCapture1(TIM2);
    304                  TIM_SetCompare1(TIM2, capture + CCR1_Val);
    305              }
    306              else if (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET)
    307              {
    308                  TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);
    309                  //beep
    310                  //Beep_OutPWM();
    311                  capture = TIM_GetCapture2(TIM2);
    312                  TIM_SetCompare2(TIM2, capture + CCR2_Val);
    313              }
    314              else if (TIM_GetITStatus(TIM2, TIM_IT_CC3) != RESET)
    315              {
    316                  TIM_ClearITPendingBit(TIM2, TIM_IT_CC3);
    317          
    318          
    319                  capture = TIM_GetCapture3(TIM2);
    320                  TIM_SetCompare3(TIM2, capture + CCR3_Val);
    321              }
    322              else
    323              {
    324                  TIM_ClearITPendingBit(TIM2, TIM_IT_CC4);
    325          
    326          
    327                  capture = TIM_GetCapture4(TIM2);
    328                  TIM_SetCompare4(TIM2, capture + CCR4_Val);
    329              }
    330          }
    331          
    332          void EXTI2_IRQHandler(void)
    333          {
    334          	 if(EXTI_GetITStatus(EXTI_Line2) != RESET)
    335          	  {
    336          			EXTI_ClearITPendingBit(EXTI_Line2); //
    337          			Touch_flag=1;
    338          			/* Clear the EXTI line 9 pending bit */ 				
    339          	  } 
    340          			EXTI_ClearITPendingBit(EXTI_Line2); //
    341          	 
    342          }
    343          
    344          /*******************************************************************************
    345           * Function Name  : USART1_IRQHandler
    346           * Description    : This function handles USART1 global interrupt request.
    347           * Input          : None
    348           * Output         : None
    349           * Return         : None
    350           *******************************************************************************/
    351          void USART1_IRQHandler(void)
    352          {
    353              u8 uRevData;
                        ^
Warning[Pe550]: variable "uRevData" was set but never used
    354              //
    355          
    356          
    357              if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    358              {
    359                  /* Read one byte from the receive data register */
    360                  uRevData = (u8)USART_ReceiveData(USART1);
    361                 
    362          
    363          
    364          
    365              }
    366              if (USART_GetITStatus(USART1, USART_IT_TXE) != RESET)
    367              {
    368              }
    369          }
    370          /*******************************************************************************
    371           * Function Name  : USART2_IRQHandler
    372           * Description    : This function handles USART2 global interrupt request.
    373           * Input          : None
    374           * Output         : None
    375           * Return         : None
    376           *******************************************************************************/
    377          void USART2_IRQHandler(void)
    378          {
    379             // u8 uRevData;
    380             // u8 checksum = 0, i = 0;
    381             #if 0//miller.tao20150723
    382              if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    383              {
    384                  /* Read one byte from the receive data register */
    385                  uRevData = (u8)USART_ReceiveData(USART2);
    386              }
    387              if (USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
    388              {
    389              }
    390              #endif
    391             ////////miller.tao20150723//////////
    392             	if(USART_GetFlagStatus(USART2, USART_FLAG_ORE) != RESET)		
    393          	{
    394          		  USART_ClearFlag(USART2, USART_FLAG_ORE);
    395          		  Uart_data_temp=USART_ReceiveData(USART2);//tiger		  
    396          	}
    397          	
    398          	//BYTE temp;
    399          	  if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    400          	  {
    401          		    USART_ClearITPendingBit(USART2, USART_IT_RXNE);
    402          	    	    //temp=USART_ReceiveData(UART4);	
    403          		    ARM_Data_Receive();	    	    
    404          	  }		
    405          
    406          	 USART_ClearITPendingBit(USART2, USART_IT_RXNE);	
    407          }
    408          
    409          /*******************************************************************************
    410           * Function Name  : USART3_IRQHandler
    411           * Description    : This function handles USART3 global interrupt request.
    412           * Input          : None
    413           * Output         : None
    414           * Return         : None
    415           *******************************************************************************/
    416          //BYTE GPSDebug[15];
    417          //BYTE gpsdebugindex=0;
    418          void USART3_IRQHandler(void)
    419          	{
    420          		vu8 uRevData;
    421          		BYTE uChecksum,i;//,index_backup;
    422          		//msg_data_t cmd;
    423          		/********************************************************************/
    424          		if (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
    425          		{
    426          			/* Read one byte from the receive data register */
    427          			uRevData = USART_ReceiveData(USART3);
    428          	
    429          			//-------------------------------------------
    430          			if(g_GPS_DATA.RxFinishTimer ==0)
    431          			{
    432          				g_GPS_DATA.RxIndex=0;
    433          				g_GPS_DATA.RxWriteIndex++;
    434          				g_GPS_DATA.RxWriteIndex %= IPC_RX_GROUP_MAX;
    435          			}
    436          	
    437          			g_GPS_DATA.RxFinishTimer = 10;
    438          	
    439          			g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][g_GPS_DATA.RxIndex] = uRevData;
    440          			g_GPS_DATA.RxIndex++;
    441          			if (g_GPS_DATA.RxIndex >= IPC_RX_BUF_MAX)
    442          			{
    443          				g_GPS_DATA.RxIndex = IPC_RX_BUF_MAX - 1;
    444          			}
    445          	
    446          			if (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0xEE)
    447          						//exit gps system
    448          					{
    449          						//g_GPS_DATA.uGPSExitFlag = 1;
    450          						g_GPS_DATA.RxFinishTimer=0;
    451          						//cmd.msgbuf[0]=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0];
    452          						//MSG_SendcmdMesssage(&cmd);
    453          					}
    454          					else if (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0xAA)
    455          						//sound start
    456          					{
    457          						g_GPS_DATA.uSoundFlag = 1;
    458          						g_GPS_DATA.RxFinishTimer=0;
    459          						//cmd.msgbuf[0]=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0];
    460          						//MSG_SendcmdMesssage(&cmd);
    461          						
    462          						//SW_GPS_CAR_TO_GPS();
    463          					}
    464          					else if (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0x55)
    465          						//sound end
    466          					{
    467          						g_GPS_DATA.uSoundFlag = 0;
    468          						g_GPS_DATA.RxFinishTimer=0;
    469          						//cmd.msgbuf[0]=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0];
    470          						//MSG_SendcmdMesssage(&cmd);
    471          						
    472          						//SW_GPS_CAR_TO_CAR();
    473          					}
    474          					else if (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0x14)//navi version
    475          					{
    476          						if(g_GPS_DATA.RxIndex>5)
    477          						{
    478          											   
    479          							
    480          							  uChecksum=0;
    481          							  for(i=0;i<5;i++)
    482          							  uChecksum+=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][i];
    483          							  uChecksum=uChecksum^0xFF;
    484          							  if(uChecksum==g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][5])
    485          							  {
    486          								/*
    487          								g_struct_navi_ver.notify=1;
    488          								g_struct_navi_ver.code0=   (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0]);
    489          								g_struct_navi_ver.code1=   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][1];
    490          								g_struct_navi_ver.code2=   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][2];
    491          								g_struct_navi_ver.code3=   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][3];
    492          								g_struct_navi_ver.code4=   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][4]; 
    493          								*/
    494          	//hour
    495          							  }
    496          								
    497          												
    498          										g_GPS_DATA.RxFinishTimer=0;
    499          										//for(i=0;i<=4;i++)
    500          										 // cmd.msgbuf[i]=g_GPS_DATA.Rx[g_GPS_DATA.
    501          	//RxWriteIndex][i];
    502          							   // MSG_SendcmdMesssage(&cmd);
    503          							  }
    504          					}				
    505          				#if 1
    506          					else if (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0xF1)
    507          					{
    508          					  if(g_GPS_DATA.RxIndex>9)
    509          						{
    510          							
    511          						  uChecksum=0;
    512          						  for(i=0;i<9;i++)
    513          						  uChecksum+=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][i];
    514          						  uChecksum=uChecksum^0xFF;
    515          						  if(uChecksum==g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][9])
    516          						  {
    517          							
    518          							m_BMW_CAN.send_time_flag=1;
    519          							m_BMW_CAN.Year_data   =   (g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][1]<<8)|g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][2];
    520          	
    521          							m_BMW_CAN.Month_data  =   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][3];
    522          							m_BMW_CAN.day_data	  =   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][5];
    523          							m_BMW_CAN.week_data   =   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][4];
    524          							m_BMW_CAN.Hour_data   =   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][6]; //
    525          							m_BMW_CAN.Minute_data =   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][7]; 
    526          	//时间数据
    527          							m_BMW_CAN.Sec_data	  =   g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][8];
    528          	                        //if(gNaviCnt>250)gNaviCnt=200;
    529          	                        if(gNaviSystemOn)
    530          	                        {
    531          	                           gNaviSystemOn=0;
    532          							   gNaviSendFlag=1;
    533                                         //gNaviCnt=3200;
    534          							}
    535          	//时间数据
    536          						  }
    537          								
    538          				  g_GPS_DATA.RxFinishTimer=0;
    539          				 // for(i=0;i<=9;i++)
    540          				 // cmd.msgbuf[i]=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][i];
    541          					//	MSG_SendcmdMesssage(&cmd);
    542          					  }
    543          					}
    544          				#endif
    545          					else if(g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0x03)
    546          					{
    547          						 g_GPS_DATA.RxFinishTimer=0;
    548          					  }
    549          					  else if(g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0]==0x05)//蓝牙挂断
    550          					  {
    551          						 
    552          						  g_GPS_DATA.RxFinishTimer=0;
    553          					   }
    554          					  else if(g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][0] == 0x52)
    555          						{
    556          						
    557          							if(g_GPS_DATA.RxIndex>5)
    558          							{
    559          								uChecksum=0;
    560          								for(i=0;i<5;i++)
    561          								uChecksum+=g_GPS_DATA.Rx[g_GPS_DATA.RxWriteIndex][i];
    562          								uChecksum=uChecksum^0xFF;
    563          
    564          								g_GPS_DATA.RxFinishTimer=0;
    565          							}
    566          						}
    567          			//-------------------------------------------
    568          			USART_ClearITPendingBit(USART3, USART_IT_RXNE);
    569          		}
    570          	}
    571          
    572          //#ifdef AUDI_Q3_TFT_MAIN_BOARD
    573          void UART4_IRQHandler(void)
    574          {
    575              u8 uRevData;
                        ^
Warning[Pe550]: variable "uRevData" was set but never used
    576              if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)
    577              {
    578                  /* Read one byte from the receive data register */
    579                  uRevData = USART_ReceiveData(UART4);
    580          
    581                  //-------------------------------------------
    582          
    583                  //-------------------------------------------
    584                  USART_ClearITPendingBit(UART4, USART_IT_RXNE);
    585              }
    586          
    587          }
    588          //#endif
    589          /*******************************************************************************
    590           * Function Name  : UART5_IRQHandler
    591           * Description    : This function handles UART5 global interrupt request.
    592           * Input          : None
    593           * Output         : None
    594           * Return         : None
    595           *******************************************************************************/
    596          void UART5_IRQHandler(void)
    597          {
    598              u8 uRevData;
    599              if (USART_GetITStatus(UART5, USART_IT_RXNE) != RESET)
    600              {
    601                  /* Read one byte from the receive data register */
    602                  uRevData = USART_ReceiveData(UART5);
    603                  uRevData = uRevData;
    604                  USART_ClearITPendingBit(UART5, USART_IT_RXNE);
    605              }
    606          }
    607          
    608          
    609          /**
    610            * @brief  This function handles CAN1 RX0 Handler.
    611            * @param  None
    612            * @retval None
    613            */
    614          
    615          CanRxMsg myRxMessage;
    616          void CAN1_RX0_IRQHandler(void)
    617          {
    618              CanRxMsg RxMessage;
    619              CAN_Receive(CAN1, CAN_FIFO0, &RxMessage);
    620          	myRxMessage =RxMessage;
    621          
    622              CAN2_USER_HANDLER(RxMessage);
    623              
    624          }
    625          
    626          /**
    627            * @brief  This function handles CAN2 RX0 Handler.
    628            * @param  None
    629            * @retval None
    630            */
    631          
    632          void CAN2_RX0_IRQHandler(void)
    633          {
    634              CanRxMsg RxMessage;
    635          
    636              CAN_Receive(CAN2, CAN_FIFO0, &RxMessage);
    637          	myRxMessage =RxMessage;
    638          	CAN2_USER_HANDLER(RxMessage);
    639          }
    640          
    641          /**
    642            * @brief  This function handles RTC global interrupt request.
    643            * @param  None
    644            * @retval None
    645            */
    646          void RTC_IRQHandler(void)
    647          {
    648              if (RTC_GetITStatus(RTC_IT_ALR) != RESET)
    649              {
    650                  /* Clear Interrupt pending bit */
    651                  RTC_ClearITPendingBit(RTC_FLAG_ALR);
    652              }
    653          }
    654          
    655          /*******************************************************************************
    656          * Function Name  : RTCAlarm_IRQHandler
    657          * Description    : This function handles RTC Alarm interrupt request.
    658          * Input          : None
    659          * Output         : None
    660          * Return         : None
    661          *******************************************************************************/
    662          void RTCAlarm_IRQHandler(void)
    663          {
    664            if(RTC_GetITStatus(RTC_IT_ALR) != RESET)
    665            {
    666              /* Toggle Led connected to GPIO_LED Pin8 */
    667              	//GPIO_WriteBit(GPIOB, P_PEC_CLK, (BitAction)(1-GPIO_ReadOutputDataBit(GPIOB, P_PEC_CLK)));
    668          
    669              /* Clear EXTI line17 pending bit */
    670              EXTI_ClearITPendingBit(EXTI_Line17);
    671          
    672          	//IWDG_ReloadCounter();//清狗
    673          	
    674              /* Check if the Wake-Up flag is set */
    675              if(PWR_GetFlagStatus(PWR_FLAG_WU) != RESET)
    676              {
    677                /* Clear Wake Up flag */
    678                PWR_ClearFlag(PWR_FLAG_WU);
    679              }
    680          
    681              /* Wait until last write operation on RTC registers has finished */
    682              RTC_WaitForLastTask();   
    683              /* Clear RTC Alarm interrupt pending bit */
    684              RTC_ClearITPendingBit(RTC_IT_ALR);
    685              /* Wait until last write operation on RTC registers has finished */
    686              RTC_WaitForLastTask();
    687            }
    688          }
    689          
    690          /******************************************************************************/
    691          /*                 STM32F10x Peripherals Interrupt Handlers                   */
    692          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    693          /*  available peripheral interrupt handler's name please refer to the startup */
    694          /*  file (startup_stm32f10x_xx.s).                                            */
    695          /******************************************************************************/
    696          
    697          /**
    698            * @brief  This function handles PPP interrupt request.
    699            * @param  None
    700            * @retval None
    701            */
    702          /*void PPP_IRQHandler(void)
    703          {
    704          }*/
    705          
    706          /**
    707            * @}
    708            */
    709          
    710          
    711          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  BusFault_Handler
       48  CAN1_RX0_IRQHandler
             32 -> CAN2_USER_HANDLER
             32 -> CAN_Receive
             32 -> __aeabi_memcpy4
             48 -> __aeabi_memcpy4
       48  CAN2_RX0_IRQHandler
             32 -> CAN2_USER_HANDLER
             32 -> CAN_Receive
             32 -> __aeabi_memcpy4
             48 -> __aeabi_memcpy4
        0  DebugMon_Handler
        8  EXTI2_IRQHandler
              8 -> EXTI_ClearITPendingBit
              8 -> EXTI_GetITStatus
        0  HardFault_Handler
        0  MemManage_Handler
        0  NMI_Handler
        0  PendSV_Handler
        8  RTCAlarm_IRQHandler
              8 -> EXTI_ClearITPendingBit
              8 -> PWR_ClearFlag
              8 -> PWR_GetFlagStatus
              8 -> RTC_ClearITPendingBit
              8 -> RTC_GetITStatus
              8 -> RTC_WaitForLastTask
        8  RTC_IRQHandler
              8 -> RTC_ClearITPendingBit
              8 -> RTC_GetITStatus
        0  SVC_Handler
        8  SysTick_Handler
              8 -> BAT_Detect_Int
              8 -> IWDG_ReloadCounter
        8  TIM2_IRQHandler
              8 -> IN_MTN5_IRSendCodeTask
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetCapture1
              8 -> TIM_GetCapture2
              8 -> TIM_GetCapture3
              8 -> TIM_GetCapture4
              8 -> TIM_GetITStatus
              8 -> TIM_SetCompare1
              8 -> TIM_SetCompare2
              8 -> TIM_SetCompare3
              8 -> TIM_SetCompare4
        8  UART4_IRQHandler
              8 -> USART_ClearITPendingBit
              8 -> USART_GetITStatus
              8 -> USART_ReceiveData
        8  UART5_IRQHandler
              8 -> USART_ClearITPendingBit
              8 -> USART_GetITStatus
              8 -> USART_ReceiveData
        8  USART1_IRQHandler
              8 -> USART_GetITStatus
              8 -> USART_ReceiveData
        8  USART2_IRQHandler
              8 -> ARM_Data_Receive
              8 -> USART_ClearFlag
              8 -> USART_ClearITPendingBit
              8 -> USART_GetFlagStatus
              8 -> USART_GetITStatus
              8 -> USART_ReceiveData
       16  USART3_IRQHandler
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
        0  UsageFault_Handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_29
       4  ??DataTable9_3
       4  ??DataTable9_30
       4  ??DataTable9_31
       4  ??DataTable9_32
       4  ??DataTable9_33
       4  ??DataTable9_34
       4  ??DataTable9_35
       4  ??DataTable9_36
       4  ??DataTable9_37
       4  ??DataTable9_38
       4  ??DataTable9_39
       4  ??DataTable9_4
       4  ??DataTable9_40
       4  ??DataTable9_41
       4  ??DataTable9_42
       4  ??DataTable9_43
       4  ??DataTable9_44
       4  ??DataTable9_45
       4  ??DataTable9_46
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       2  BusFault_Handler
      46  CAN1_RX0_IRQHandler
      46  CAN2_RX0_IRQHandler
       2  DebugMon_Handler
      34  EXTI2_IRQHandler
       2  HardFault_Handler
       2  MemManage_Handler
       2  NMI_Handler
       2  PendSV_Handler
      52  RTCAlarm_IRQHandler
      20  RTC_IRQHandler
       2  SVC_Handler
     866  SysTick_Handler
     248  TIM2_IRQHandler
      36  UART4_IRQHandler
      36  UART5_IRQHandler
      42  USART1_IRQHandler
      86  USART2_IRQHandler
     788  USART3_IRQHandler
       2  UsageFault_Handler
       2  capture
      20  g_RxMessage
      20  myRxMessage
       2  u100MsClrWdgCount
       2  u10MsCount

 
    46 bytes in section .bss
 2 504 bytes in section .text
 
 2 504 bytes of CODE memory
    46 bytes of DATA memory

Errors: none
Warnings: 2
